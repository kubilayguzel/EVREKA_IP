// functions/index.js
import admin from 'firebase-admin';
import path from 'path';
import os from 'os';
import fs from 'fs';
import AdmZip from 'adm-zip';
import { createExtractorFromFile } from 'node-unrar-js';
import nodemailer from 'nodemailer';
import stream from 'stream';
import { pipeline } from 'stream/promises';
import { onRequest, onCall, HttpsError } from 'firebase-functions/v2/https';
import { onSchedule } from 'firebase-functions/v2/scheduler';
import { onDocumentCreated, onDocumentUpdated, onDocumentWritten } from 'firebase-functions/v2/firestore';
import { onMessagePublished } from 'firebase-functions/v2/pubsub';
import { onObjectFinalized } from 'firebase-functions/v2/storage';
import logger from 'firebase-functions/logger';
import cors from 'cors';
import fetch from 'node-fetch';
import { PubSub } from '@google-cloud/pubsub';
import archiver from 'archiver';
import { Document, Packer, Paragraph, TextRun, Table, TableRow, TableCell,
         WidthType, AlignmentType, HeadingLevel, PageBreak } from 'docx';
import { SecretManagerServiceClient } from "@google-cloud/secret-manager";
import { google } from "googleapis";
import { auth } from 'firebase-functions/v1';
import { getAuth } from 'firebase-admin/auth';                          // Admin SDK (mod√ºler)
import { getFirestore, FieldValue } from 'firebase-admin/firestore';    // Admin SDK (mod√ºler)
import { addMonthsToDate, findNextWorkingDay, isHoliday, isWeekend, TURKEY_HOLIDAYS } from '../utils.js';

// Initialize Firebase Admin
if (!admin.apps.length) {
  admin.initializeApp();
}

const adminAuth = admin.auth();
const adminDb = admin.firestore();
const db        = adminDb;
const secretClient = new SecretManagerServiceClient();

// üîê SA_MAILER_KEY'i Secret Manager'dan √ßek
async function loadMailerSA() {
  const name = `projects/${process.env.GCLOUD_PROJECT}/secrets/SA_MAILER_KEY/versions/latest`;
  const [ver] = await secretClient.accessSecretVersion({ name });
  return JSON.parse(ver.payload.data.toString("utf8")); // { client_email, private_key, ... }
}

// ‚úÖ G√∂ndermeye yetkili ki≈üiler
const ALLOWED_SENDERS = new Set([
  "alikucuksahin@evrekapatent.com",
  "bekirguven@evrekapatent.com",
  "kubilayguzel@evrekapatent.com",
  "erhankocabacak@evrekapatent.com",
  "selcanakoglu@evrekapatent.com",
  "hukuk@evrekapatent.com",
  "beyzasevinc@evrekapatent.com",
  "yigitdemirtas@evrekapatent.com",
  "rumeysatimurlenk@evrekapatent.com"
]);

// üìß Gmail API ile "kullanƒ±cƒ±nƒ±n adƒ±na" g√∂nderim
async function sendViaGmailAsUser(userEmail, mailOptions) {
  const sa = await loadMailerSA();

  // 1) Nodemailer ile MIME √ºret (ekleri de dahil)
  const streamTransport = nodemailer.createTransport({
    streamTransport: true,
    newline: "unix",
    buffer: true
  });

  const compiled = await streamTransport.sendMail({
    ...mailOptions,
    from: `"${mailOptions.fromName || "IP Manager"}" <${userEmail}>`,
    sender: undefined,
    replyTo: mailOptions.replyTo || userEmail
  });

  const raw = Buffer.from(compiled.message)
    .toString("base64")
    .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");

  // 2) Domain-Wide Delegation ile o kullanƒ±cƒ± adƒ±na yetkilendirme
  const auth = new google.auth.JWT({
    email: sa.client_email,
    key: sa.private_key,
    scopes: ["https://www.googleapis.com/auth/gmail.send"],
    subject: userEmail      // << kullanƒ±cƒ± adƒ±na g√∂nder
  });

  const gmail = google.gmail({ version: "v1", auth });
  const res = await gmail.users.messages.send({
    userId: "me",
    requestBody: { raw }
  });

  return res.data; // { id, ... }
}


// Firebase Admin SDK'sƒ±nƒ± ba≈ülatƒ±n
if (!admin.apps.length) {
  admin.initializeApp();
}
const pubsubClient = new PubSub(); // pubsubClient'ƒ± burada tanƒ±mlayƒ±n

// ********************************************************************************
async function ensureTopic(name) {
  try {
    const [exists] = await pubsubClient.topic(name).exists();
    if (!exists) {
      await pubsubClient.createTopic(name);
      console.log(`üÜï Pub/Sub topic created: ${name}`);
    }
  } catch (err) {
    console.error(`‚ö†Ô∏è ensureTopic error for ${name}:`, err.message || err);
    throw err;
  }
}

// CORS ayarlarƒ±
const corsOptions = {
    origin: [
        'https://kubilayguzel.github.io',
        'http://localhost:3000',
        'http://127.0.0.1:3000',
        'http://localhost:5173'
    ],
    credentials: true,
    optionsSuccessStatus: 200
};
const corsHandler = cors(corsOptions);

// SMTP transporter configuration
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: "kubilayguzel@evrekapatent.com",
    pass: "rqvl tpbm vkmu lmxi"
  }
});

// =========================================================
//              HTTPS FONKSƒ∞YONLARI (v2)
// =========================================================

// ETEBS API Proxy Function (v2 s√∂zdizimi)
export const etebsProxyV2 = onRequest(
    {
        region: 'europe-west1',
        timeoutSeconds: 120,
        memory: '256MiB'
    },
    async (req, res) => {
        return corsHandler(req, res, async () => {
            if (req.method !== 'POST') {
                return res.status(405).json({
                    success: false,
                    error: 'Method not allowed'
                });
            }

            try {
                console.log('üî• ETEBS Proxy request:', req.body);

                const { action, token, documentNo, userId } = req.body;

                if (!action || !token) {
                    return res.status(400).json({
                        success: false,
                        error: 'Missing required parameters'
                    });
                }

                let apiUrl = '';
                let requestBody = { TOKEN: token };
                let etebsData;

                switch (action) {
                    case 'daily-notifications':
                        apiUrl = 'https://epats.turkpatent.gov.tr/service/TP/DAILY_NOTIFICATIONS?apikey=etebs';
                        const etebsResponse = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(requestBody),
                            timeout: 30000
                        });
                        if (!etebsResponse.ok) {
                            throw new Error(`ETEBS API HTTP ${etebsResponse.status}: ${etebsResponse.statusText}`);
                        }
                        etebsData = await etebsResponse.json();
                        break;

                    case 'download-document':
                        if (!documentNo) {
                            return res.status(400).json({
                                success: false,
                                error: 'Document number required for download'
                            });
                        }
                        apiUrl = 'https://epats.turkpatent.gov.tr/service/TP/DOWNLOAD_DOCUMENT?apikey=etebs';
                        requestBody.DOCUMENT_NO = documentNo;
                        
                        const etebsDownloadResponse = await fetch(apiUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'User-Agent': 'IP-Manager-ETEBS-Proxy/1.0'
                            },
                            body: JSON.stringify(requestBody),
                            timeout: 30000
                        });
                        if (!etebsDownloadResponse.ok) {
                            throw new Error(`ETEBS API HTTP ${etebsDownloadResponse.status}: ${etebsDownloadResponse.statusText}`);
                        }
                        
                        const etebsRawData = await etebsDownloadResponse.json();
                        const downloadResult = etebsRawData.DownloadDocumentResult || [];
                        
                        if (downloadResult.length > 0) {
                            const firstDoc = downloadResult[0];
                            const base64Data = firstDoc.BASE64;
                            const belgeAciklamasi = firstDoc.BELGE_ACIKLAMASI;
                            
                            // Base64'ten Buffer'a d√∂n√º≈üt√ºr
                            const pdfBuffer = Buffer.from(base64Data, 'base64');
                            
                            // Dosya adƒ± ve yolu olu≈ütur
                            const fileName = `${documentNo}_${belgeAciklamasi.replace(/[^a-zA-Z0-9_]/g, '')}.pdf`;
                            const storagePath = `etebs_documents/${userId || 'anonymous'}/${documentNo}/${fileName}`;
                            
                            // Dosyayƒ± Firebase Storage'a y√ºkle
                            const file = admin.storage().bucket().file(storagePath);
                            await file.save(pdfBuffer, { contentType: 'application/pdf' });
                            
                            // Firestore'a dosya bilgisini kaydet
                            const firestoreDocRef = adminDb.collection('unindexed_pdfs').doc();
                            await firestoreDocRef.set({
                                evrakNo: documentNo,
                                belgeAciklamasi: belgeAciklamasi,
                                fileName: fileName,
                                filePath: storagePath,
                                fileUrl: `https://storage.googleapis.com/${admin.storage().bucket().name}/${storagePath}`,
                                createdAt: admin.firestore.FieldValue.serverTimestamp(),
                                status: 'pending',
                                source: 'etebs'
                            });
                            
                            // ƒ∞stemciye ba≈üarƒ± durumunu ve dosya URL'ini d√∂nd√ºr
                            etebsData = {
                                fileUrl: `https://storage.googleapis.com/${admin.storage().bucket().name}/${storagePath}`,
                                unindexedPdfId: firestoreDocRef.id,
                                message: 'Evrak ba≈üarƒ±yla kaydedildi'
                            };

                        } else {
                             etebsData = { success: false, error: 'Evraka ait ek bulunamadƒ±.', errorCode: '006' };
                        }
                        break;
                    default:
                        return res.status(400).json({
                            success: false,
                            error: 'Invalid action'
                        });
                }

                console.log('‚úÖ ETEBS API response received');

                res.json({
                    success: true,
                    data: etebsData,
                    timestamp: new Date().toISOString()
                });

            } catch (error) {
                console.error('‚ùå ETEBS Proxy Error:', error);
                res.status(500).json({
                    success: false,
                    error: 'Internal proxy error',
                    code: 'PROXY_ERROR',
                    message: process.env.NODE_ENV === 'development' ? error.message : undefined
                });
            }
        });
    }
);

// Health Check Function (v2 s√∂zdizimi)
export const etebsProxyHealthV2 = onRequest(
    {
        region: 'europe-west1'
    },
    (req, res) => {
        return corsHandler(req, res, () => {
            res.json({
                status: 'healthy',
                service: 'ETEBS Proxy',
                timestamp: new Date().toISOString(),
                version: '1.0.0'
            });
        });
    }
);

// ETEBS Token Validation Function (v2 s√∂zdizimi)
export const validateEtebsTokenV2 = onRequest(
    {
        region: 'europe-west1'
    },
    (req, res) => {
        return corsHandler(req, res, () => {
            if (req.method !== 'POST') {
                return res.status(405).json({ error: 'Method not allowed' });
            }

            const { token } = req.body;

            if (!token) {
                return res.status(400).json({
                    valid: false,
                    error: 'Token required'
                });
            }

            const guidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

            if (!guidRegex.test(token)) {
                return res.status(400).json({
                    valid: false,
                    error: 'Invalid token format'
                });
            }

            res.json({
                valid: true,
                format: 'GUID',
                timestamp: new Date().toISOString()
            });
        });
    }
);
// Storage'taki PDF dosyasƒ±nƒ± bulup Nodemailer'a eklenti (attachment) olarak vermek.
async function buildNotificationAttachments(db, notificationData) {
  const result = { attachments: [], footerItems: [] };
  const MAX_BYTES = 20 * 1024 * 1024; // 20MB
  const bucket = admin.storage().bucket();

  const safeName = (name, def = "document.pdf") =>
    String(name || def).replace(/[^\w.\-]+/g, "_").slice(0, 100);

  const pathFromURL = (url) => {
    try {
      const m = new URL(url).pathname.match(/\/o\/(.+?)(?:\?|$)/);
      return m ? decodeURIComponent(m[1]) : null;
    } catch { return null; }
  };

  const addAsAttachmentOrLink = async ({ storagePath, downloadURL, fileName }) => {
    const name = safeName(fileName);
    if (!storagePath) {
      // path yoksa linke d√º≈ü
      if (downloadURL) {
        result.footerItems.push(
          `<a href="${downloadURL}" target="_blank" rel="noopener">${name}</a>`
        );
      } else {
        result.footerItems.push(name);
      }
      return true;
    }
    try {
      const [meta] = await bucket.file(storagePath).getMetadata();
      const size = Number(meta.size || 0);
      if (size > MAX_BYTES) {
        if (downloadURL) {
          result.footerItems.push(
            `<a href="${downloadURL}" target="_blank" rel="noopener">${name}</a>`
          );
        } else {
          result.footerItems.push(name);
        }
        return true;
      }
      const [buf] = await bucket.file(storagePath).download();
      result.attachments.push({
        filename: name,
        content: buf,
        contentType: "application/pdf",
      });
      return true;
    } catch (e) {
      // storage eri≈üilemezse son √ßare link
      if (downloadURL) {
        result.footerItems.push(
          `<a href="${downloadURL}" target="_blank" rel="noopener">${name}</a>`
        );
        return true;
      }
      return false;
    }
  };

  try {
    console.log("üîç [ATTACH] builder start", {
      associatedTaskId: notificationData?.associatedTaskId,
      sourceDocumentId: notificationData?.sourceDocumentId,
    });

    // 1) √ñNCE: Task ‚Üí EPATS (TaskComplete akƒ±≈üƒ±)
    const taskId = notificationData?.associatedTaskId;
    if (taskId) {
      try {
        const t = await adminDb.collection("tasks").doc(taskId).get();
        const ep = t.exists ? (t.data()?.details?.epatsDocument || null) : null;
        if (ep) {
          let storagePath = ep.storagePath || pathFromURL(ep.downloadURL || ep.fileUrl);
          await addAsAttachmentOrLink({
            storagePath,
            downloadURL: ep.downloadURL || ep.fileUrl || null,
            fileName: ep.name || "epats.pdf",
          });
          return result; // EPATS bulunduysa burada biter
        }
      } catch (e) {
        console.warn("‚ö†Ô∏è [ATTACH] task/EPATS okunamadƒ±:", e?.message || e);
      }
    }

    // 2) SONRA: unindexed_pdfs (DocumentStatusChange akƒ±≈üƒ±)
    const docId = notificationData?.sourceDocumentId;
    if (docId) {
      try {
        const u = await adminDb.collection("unindexed_pdfs").doc(docId).get();
        if (u.exists) {
          const d = u.data() || {};
          let storagePath = d.filePath || pathFromURL(d.fileUrl || d.downloadURL);
          await addAsAttachmentOrLink({
            storagePath,
            downloadURL: d.fileUrl || d.downloadURL || null,
            fileName: d.fileName || "document.pdf",
          });
          return result;
        }
      } catch (e) {
        console.warn("‚ö†Ô∏è [ATTACH] unindexed_pdfs okunamadƒ±:", e?.message || e);
      }
    }

    // 3) Aksi halde ek yok
    return result;
  } catch (err) {
    console.error("‚ùå [ATTACH] Genel hata:", err);
    return result;
  }
}

export const createObjectionTask = onCall({ region: 'europe-west1' }, async (request) => {
const { monitoredMarkId, similarMark, bulletinNo, callerEmail } = request.data || {};

  // ‚úÖ 1. B√ºlten tarihini al
  let bulletinDate = null;        // Date | null
  let bulletinDateStr = null;     // string | null

  try {
    const bulletinQuery = await admin.firestore()
      .collection('trademarkBulletins')
      .where('bulletinNo', '==', bulletinNo)
      .limit(1)
      .get();

    if (!bulletinQuery.empty) {
      const bulletinData = bulletinQuery.docs[0].data();
      bulletinDateStr = bulletinData.bulletinDate; // "12/08/2025" formatƒ±nda

      // "DD/MM/YYYY" ‚Üí Date objesi
      if (bulletinDateStr && typeof bulletinDateStr === 'string') {
        const parts = bulletinDateStr.split('/');
        bulletinDate = new Date(
          parseInt(parts[2], 10),
          parseInt(parts[1], 10) - 1,
          parseInt(parts[0], 10)
        );
        bulletinDate.setHours(0, 0, 0, 0);

        console.log('‚úÖ B√ºlten tarihi bulundu:', {
          bulletinNo,
          bulletinDateStr,
          bulletinDate: bulletinDate.toISOString(),
        });
      }
    } else {
      console.warn('‚ö†Ô∏è B√ºlten bulunamadƒ±:', bulletinNo);
    }
  } catch (err) {
    console.error('‚ùå B√ºlten tarihi alƒ±namadƒ±:', err);
  }

  // ‚úÖ 2. dueDate hesaplama: B√ºlten tarihi + 2 ay
  let officialDueDate = null;      // Date | null
  let operationalDueDate = null;   // Date | null
  let dueDateDetails = null;       // any

  if (bulletinDate) {
    try {
      // 1) B√ºlten tarihine 2 ay ekle
      const rawDueDate = addMonthsToDate(bulletinDate, 2);

      // 2) Resmi tatil/hafta sonu ‚Üí ilk i≈ü g√ºn√ºne kaydƒ±r
      officialDueDate = findNextWorkingDay(rawDueDate, TURKEY_HOLIDAYS);

      // 3) Operasyonel son tarih = Resmi son tarih - 3 g√ºn
      const tempOperationalDueDate = new Date(officialDueDate);
      tempOperationalDueDate.setDate(officialDueDate.getDate() - 3);
      tempOperationalDueDate.setHours(0, 0, 0, 0);

      // 4) Operasyonel tarihi de tatil kontrol√ºnden ge√ßir (geriye doƒüru)
      let checkDate = new Date(tempOperationalDueDate);
      while (isWeekend(checkDate) || isHoliday(checkDate, TURKEY_HOLIDAYS)) {
        checkDate.setDate(checkDate.getDate() - 1);
      }
      operationalDueDate = checkDate;

      // 5) Hesaplama detaylarƒ±
      dueDateDetails = {
        bulletinDate: bulletinDate.toISOString().split('T')[0],
        periodMonths: 2,
        originalCalculatedDate: rawDueDate.toISOString().split('T')[0],
        finalOfficialDueDate: officialDueDate.toISOString().split('T')[0],
        finalOperationalDueDate: operationalDueDate.toISOString().split('T')[0],
        adjustments: [],
      };

      console.log('‚úÖ dueDate hesaplandƒ±:', dueDateDetails);
    } catch (err) {
      console.error('‚ùå dueDate hesaplama hatasƒ±:', err);
    }
  } else {
    console.warn('‚ö†Ô∏è B√ºlten tarihi bulunamadƒ±, dueDate hesaplanamadƒ±');
  }

  // ‚úÖ 3. Task verilerini olu≈ütur
  // TODO: clientId kaynaƒüƒ±nƒ± kendi akƒ±≈üƒ±nƒ±za g√∂re doldurun
  const clientId = /* √∂rn. similarMark.clientId veya monitoredMark dok√ºmanƒ±ndan */ null;

  const taskData = {
    taskType: "20",
    status: "awaiting_client_approval",
    clientId: clientId,
    dueDate: operationalDueDate ? admin.firestore.Timestamp.fromDate(operationalDueDate) : null,
    officialDueDate: officialDueDate ? admin.firestore.Timestamp.fromDate(officialDueDate) : null,
    officialDueDateDetails: dueDateDetails,
    details: {
      bulletinNo: bulletinNo,
      bulletinDate: bulletinDateStr,
      monitoredMarkId: monitoredMarkId,
      targetAppNo: similarMark.applicationNo,
      objectionTarget: similarMark.markName,
      targetNiceClasses: similarMark.niceClasses,
      similarityScore: similarMark.similarityScore,
    },
    createdAt: admin.firestore.FieldValue.serverTimestamp(),
  };

  // Task'ƒ± Firestore'a ekle
  const taskRef = await admin.firestore().collection('tasks').add(taskData);

  return {
    success: true,
    taskId: taskRef.id,
    dueDate: operationalDueDate ? operationalDueDate.toISOString() : null,
  };
});


// Send Email Notification (v2 Callable Function)
export const sendEmailNotificationV2 = onCall(
  { region: "europe-west1" },
  async (request) => {
    const { notificationId, userEmail: userEmailFromClient, mode, overrideSubject, overrideBody } = request.data || {};
    const isReminder = String(mode || "").toLowerCase() === "reminder";
    console.log("üìß [DEBUG] sendEmailNotificationV2", { notificationId, mode, hasOverrideSubject: !!overrideSubject, hasOverrideBody: !!overrideBody });

    if (!notificationId) throw new HttpsError("invalid-argument", "notificationId parametresi zorunludur.");

    const notificationRef = db.collection("mail_notifications").doc(notificationId);
    const notificationDoc = await notificationRef.get();
    if (!notificationDoc.exists) throw new HttpsError("not-found", "Bildirim bulunamadƒ±.");

    const notificationData = notificationDoc.data();

    // G√∂nderici doƒürulama
    const callerEmail = (request.auth?.token?.email || "").toLowerCase();
    const userEmail = (userEmailFromClient || callerEmail || "").toLowerCase();
    if (!userEmail || !ALLOWED_SENDERS.has(userEmail)) {
      throw new HttpsError("permission-denied", "Bu kullanƒ±cƒ± adƒ±na g√∂nderim yetkisi yok.");
    }

    // -----------------------------
    // Alƒ±cƒ±lar (√∂ncelik sƒ±rasƒ±):
    // toList/ccList > toRecipients/ccRecipients > recipientTo/recipientCc > to/cc > recipientEmail
    // -----------------------------
    const norm = (v) => {
      if (!v) return [];
      if (Array.isArray(v)) {
        return v
          .map(x => {
            if (typeof x === "string") return x.trim();
            if (x && typeof x === "object" && x.email) return String(x.email).trim();
            return "";
          })
          .filter(Boolean);
      }
      if (typeof v === "string") {
        return v.split(/[;,]\s*/).map(s => s.trim()).filter(Boolean);
      }
      return [];
    };

    const firstNonEmpty = (...cands) => {
      for (const c of cands) {
        const arr = norm(c);
        if (arr.length) return arr;
      }
      return [];
    };

    let toArr = firstNonEmpty(
      notificationData.toList,
      notificationData.toRecipients,
      notificationData.recipientTo,
      notificationData.to,
      notificationData.recipientEmail
    );
    let ccArr = firstNonEmpty(
      notificationData.ccList,
      notificationData.ccRecipients,
      notificationData.recipientCc,
      notificationData.cc
    );

    // Tekille≈ütir ve TO i√ßinde olanƒ± CC'den √ßƒ±kar (aynƒ± adrese iki kez gitmesin)
    const uniq = (a) => Array.from(new Set(a.map(s => s.toLowerCase()))); // case-insensitive uniq
    toArr = uniq(toArr);
    ccArr = uniq(ccArr).filter(x => !toArr.includes(x));

    const to = toArr.join(", ");
    const cc = ccArr.join(", ");

    console.log("üìß [DEBUG] FINAL TO:", toArr, "FINAL CC:", ccArr);

    if (!to && !cc) {
      throw new HttpsError("failed-precondition", "G√∂nderilecek alƒ±cƒ± adresi bulunamadƒ±.");
    }

    // Ekleri hazƒ±rla (hatƒ±rlatmada ekleri kapatacaƒüƒ±z)
    const built = await buildNotificationAttachments(db, notificationData);
    const attachmentsBuilt = built?.attachments || [];
    const footerItems = built?.footerItems || [];

    // Basit <body> ayƒ±klayƒ±cƒ± (TinyMCE g√∂vdesi i√ßin)
    const stripBody = (html) => {
      if (!html) return "";
      const m = String(html).match(/<body[^>]*>([\s\S]*?)<\/body>/i);
      return m ? m[1] : String(html);
    };

    // Konu + G√∂vde
    let subject, htmlBody, attachmentsToSend;

    if (isReminder) {
      const safeOverrideSubject = (overrideSubject || "").toString().trim();
      const safeOverrideBody = stripBody((overrideBody || "").toString().trim());

      subject = safeOverrideSubject || `Hatƒ±rlatma: ${notificationData.subject || ""}`.trim();
      htmlBody = safeOverrideBody || `
        <p>Sayƒ±n ƒ∞lgili,</p>
        <p>Konuyu hatƒ±rlatmak isteriz.</p>
        <p>Saygƒ±larƒ±mƒ±zla,</p>
      `;
      attachmentsToSend = undefined; // hatƒ±rlatma yalƒ±n gitsin
    } else {
      subject = notificationData.subject || "";
      htmlBody = notificationData.body || "";

      if (footerItems.length > 0) {
        const eklerHtml = footerItems.map(item => `‚Ä¢ ${item}`).join("<br>");
        htmlBody += `<hr><p><strong>EKLER:</strong><br>${eklerHtml}</p>`;
      }
      attachmentsToSend = attachmentsBuilt.length ? attachmentsBuilt : undefined;
    }

    const mailOptions = {
      fromName: "IP Manager",
      replyTo: userEmail,
      to, cc, subject,
      html: htmlBody,
      attachments: attachmentsToSend
    };

    try {
      const sent = await sendViaGmailAsUser(userEmail, mailOptions);

      const baseUpdate = {
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        sentBy: userEmail,
        provider: "gmail_api_dwd",
        gmailMessageId: sent?.id || null,
        lastAttachmentMode: (attachmentsToSend?.length ? "attachment" : (footerItems.length ? "inline_link" : "none")),
        // Son kullanƒ±lan alƒ±cƒ±larƒ± da kayda ge√ßelim (te≈ühis i√ßin faydalƒ±)
        lastUsedTo: toArr,
        lastUsedCc: ccArr
      };

      if (isReminder) {
        await notificationRef.update({
          ...baseUpdate,
          lastReminderAt: admin.firestore.FieldValue.serverTimestamp(),
          lastReminderBy: userEmail
        });
      } else {
        await notificationRef.update({
          ...baseUpdate,
          status: "sent",
          sentAt: admin.firestore.FieldValue.serverTimestamp()
        });
      }

      return { success: true, message: "E-posta g√∂nderildi.", id: sent?.id || null };
    } catch (error) {
      console.error("üí• Gmail API g√∂nderim hatasƒ±:", error);
      await notificationRef.update({
        status: "failed",
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        errorInfo: error?.message || String(error)
      });
      throw new HttpsError("internal", "E-posta g√∂nderilirken bir hata olu≈ütu.", error?.message);
    }
  }
);

// =========================================================
//              SCHEDULER FONKSƒ∞YONLARI (v2)
// =========================================================

// Rate Limiting Function (Scheduled) (v2 s√∂zdizimi)
export const cleanupEtebsLogsV2 = onSchedule(
    {
        schedule: 'every 24 hours',
        region: 'europe-west1'
    },
    async (event) => {
        console.log('üßπ ETEBS logs cleanup started');

        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

        try {
            const oldLogs = await adminDb.collection('etebs_logs')
                .where('timestamp', '<', thirtyDaysAgo)
                .limit(500)
                .get();

            const batch = db.batch();
            oldLogs.docs.forEach(doc => {
                batch.delete(doc.ref);
            });

            await batch.commit();

            console.log(`üóëÔ∏è Cleaned up ${oldLogs.docs.length} old ETEBS logs`);
        } catch (error) {
            console.error('‚ùå Cleanup error:', error);
        }

        return null;
    }
);

// =========================================================
//              FIRESTORE TRIGGER FONKSƒ∞YONLARI (v2)
// =========================================================
export const createMailNotificationOnDocumentIndexV2 = onDocumentCreated(
  {
    document: "indexed_documents/{docId}",
    region: "europe-west1",
  },
  async (event) => {
    const snap = event.data;
    const newDocument = snap.data();
    const docId = event.params.docId;

    console.log(`üìÑ Yeni belge algƒ±landƒ±: ${docId}`, newDocument);

    // --- Yardƒ±mcƒ±lar ---
    const normalizeType = (t) => {
      const s = String(t || "").toLowerCase();
      if (["marka", "trademark"].includes(s)) return "marka";
      if (["patent"].includes(s)) return "patent";
      if (["tasarƒ±m", "tasarim", "design"].includes(s)) return "tasarim";
      if (["dava", "litigation"].includes(s)) return "dava";
      if (["muhasebe", "finance", "accounting"].includes(s)) return "muhasebe";
      return s || "marka";
    };

    const dedupe = (arr) => Array.from(new Set((arr || []).filter(Boolean).map(x => String(x).trim())));

    const findRecipientsFromPersonsRelated = async (personIds, categoryKey) => {
      const to = [];
      const cc = [];
      if (!Array.isArray(personIds) || personIds.length === 0) return { to, cc };

      try {
        // "in" sorgusu 10 id ile sƒ±nƒ±rlƒ±dƒ±r; 10'dan fazla ise par√ßa par√ßa sorgula
        const chunks = [];
        for (let i = 0; i < personIds.length; i += 10) {
          chunks.push(personIds.slice(i, i + 10));
        }
        for (const chunk of chunks) {
          const prSnap = await db
            .collection("personsRelated")
            .where("personId", "in", chunk)
            .get();

          prSnap.forEach((d) => {
            const pr = d.data();
            const email = (pr.email || "").trim();
            const isResp = pr?.responsible?.[categoryKey] === true;
            const n = pr?.notify?.[categoryKey] || {};
            if (!email || !isResp) return;
            if (n?.to === true) to.push(email);
            if (n?.cc === true) cc.push(email);
          });
        }
      } catch (e) {
        console.warn("personsRelated sorgusu hata:", e);
      }

      return { to: dedupe(to), cc: dedupe(cc) };
    };

    // --- Ba≈ülangƒ±√ß deƒüerleri ---
    const categoryKey = normalizeType(newDocument.mainProcessType || "marka");
    const notificationType = categoryKey;

    let toRecipients = [];
    let ccRecipients = [];
    let subject = "";
    let body = "";
    const missingFields = []; // sadece "recipients", "subject", "body" gibi g√∂nderimi engelleyenler eklenecek

    try {
      // 1) Kural & ≈ûablon (bulunamazsa bile fallback i√ßerik olu≈üturacaƒüƒ±z)
      let template = null;
      try {
        const rulesSnapshot = await db
          .collection("template_rules")
          .where("sourceType", "==", "document")
          .where("mainProcessType", "==", newDocument.mainProcessType || "marka")
          .where("subProcessType", "==", newDocument.subProcessType || null)
          .limit(1)
          .get();

        if (!rulesSnapshot.empty) {
          const rule = rulesSnapshot.docs[0].data();
          const templateSnapshot = await adminDb.collection("mail_templates").doc(rule.templateId).get();
          if (templateSnapshot.exists) template = templateSnapshot.data();
          else console.warn(`‚ö†Ô∏è ≈ûablon bulunamadƒ±: ${rule.templateId}`);
        } else {
          console.warn("‚ö†Ô∏è Kural bulunamadƒ± (template_rules).");
        }
      } catch (e) {
        console.warn("Kural/≈üablon ararken hata:", e);
      }

      // 2) ALICILAR ‚Äî √ñNCE taskOwner, SONRA applicants (clientId) fallback
      // Bu fonksiyon "indexed_documents" i√ßin √ßalƒ±≈üƒ±yor; tipik olarak "clientId" mevcut.
      // Eƒüer dok√ºmanda taskOwnerIds varsa √∂nce onlarƒ± kullan.
      const taskOwnerIds =
        (Array.isArray(newDocument.taskOwner) && newDocument.taskOwner) ||
        (Array.isArray(newDocument.taskOwnerIds) && newDocument.taskOwnerIds) ||
        [];

      if (taskOwnerIds.length > 0) {
        console.log("üéØ √ñncelik: taskOwner -> personsRelated", taskOwnerIds);
        const fromOwners = await findRecipientsFromPersonsRelated(taskOwnerIds, categoryKey);
        toRecipients = fromOwners.to;
        ccRecipients = fromOwners.cc;
      }

      // Eƒüer taskOwner‚Äôdan alƒ±cƒ± √ßƒ±kmadƒ±ysa ‚Üí applicants (clientId) √ºzerinden dene
      const clientId = newDocument.clientId || null;
      if ((toRecipients.length + ccRecipients.length) === 0 && clientId) {
        console.log("‚Ü™Ô∏è taskOwner‚Äôdan alƒ±cƒ± √ßƒ±kmadƒ±; applicants (clientId) fallback deneniyor:", clientId);
        const fromApplicantsPR = await findRecipientsFromPersonsRelated([clientId], categoryKey);
        toRecipients = fromApplicantsPR.to;
        ccRecipients = fromApplicantsPR.cc;

        // H√¢l√¢ yoksa getRecipientsByApplicantIds ile son kez dene
        if ((toRecipients.length + ccRecipients.length) === 0) {
          // Eƒüer ipRecord.applicants yoksa sentetik applicants [{id: clientId}]
          const rec = await getRecipientsByApplicantIds([{ id: clientId }], categoryKey);
          toRecipients = rec?.to || [];
          ccRecipients = rec?.cc || [];
        }
      }

      console.log("üìß FINAL RECIPIENTS", { toRecipients, ccRecipients });

      // 3) ≈ûABLON/ƒ∞√áERƒ∞K ‚Äî ≈ûablon yoksa da bo≈ü bƒ±rakma (missing_info olmasƒ±n diye fallback olu≈ütur)
      if (template) {
        subject = String(template.subject || "");
        body = String(template.body || "");

        const applicationNo =
          newDocument.applicationNumber ||
          newDocument.applicationNo ||
          newDocument.appNo ||
          "";

        const parameters = {
          ...newDocument,
          muvekkil_adi: newDocument.clientName || newDocument.ownerName || "Deƒüerli M√ºvekkil",
          basvuru_no: applicationNo,
        };

        subject = subject.replace(/{{\s*([\w.]+)\s*}}/g, (_, k) => parameters[k] ?? "");
        body    = body.replace(/{{\s*([\w.]+)\s*}}/g, (_, k) => parameters[k] ?? "");
      } else {
        // Temel fallback i√ßerik
        subject = `[${notificationType.toUpperCase()}] Yeni Evrak`;
        body = [
          `Merhaba,`,
          ``,
          `Sistemimize yeni bir evrak eklendi.`,
          `Evrak No / Ba≈üvuru No: ${newDocument.applicationNumber || newDocument.applicationNo || newDocument.appNo || "-"}`,
          ``,
          `Saygƒ±larƒ±mƒ±zla`
        ].join("\n");
      }

      // 4) STATUS ‚Äî SADE KURAL: sadece alƒ±cƒ± + i√ßerik
      if (!subject?.trim()) missingFields.push("subject");
      if (!body?.trim())    missingFields.push("body");

      const hasRecipients = (toRecipients.length + ccRecipients.length) > 0;
      const hasContent    = !missingFields.includes("subject") && !missingFields.includes("body");
      const status        = (hasRecipients && hasContent) ? "pending" : "missing_info";

      if (!hasRecipients) missingFields.push("recipients");

      // 5) Firestore‚Äôa yaz ‚Äî UI filtreleriyle uyumlu alanlar
      const selcanUserId = "Mkmq2sc0T6XTIg1weZyp5AGZ0YG3"; // <<< BURAYA SELCAN'IN GER√áEK ID'Sƒ∞Nƒ∞ YAPI≈ûTIRIN
      const selcanUserEmail = "selcanakoglu@evrekapatent.com"; // <<< BURAYA SELCAN'IN E-POSTA ADRESƒ∞Nƒ∞ YAZIN

      const finalStatus = (hasRecipients && hasContent) ? "awaiting_client_approval" : "missing_info";
      if (!hasRecipients) missingFields.push("recipients");
      const notificationDoc = {
        toList: dedupe(toRecipients),
        ccList: dedupe(ccRecipients),

        clientId: newDocument.clientId || null,
        subject,
        body,
        status: finalStatus, // <<< DEƒûƒ∞≈ûTƒ∞
        mode: "draft",
        isDraft: true,

        assignedTo_uid: selcanUserId,         // <<< YENƒ∞ EKLENDƒ∞
        assignedTo_email: selcanUserEmail,    // <<< YENƒ∞ EKLENDƒ∞

        sourceDocumentId: docId,
        relatedIpRecordId: newDocument.relatedIpRecordId || null,
        associatedTaskId: null,
        associatedTransactionId: null,

        templateId: template ? (template.id || template.templateId || null) : null,
        notificationType,
        source: "document_index",
        missingFields,

        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      };
  
      console.log("üì• mail_notifications.add input:", {
        ...notificationDoc,
        createdAt: "[serverTimestamp]",
        updatedAt: "[serverTimestamp]",
      });

      const ref = await adminDb.collection("mail_notifications").add(notificationDoc);
      console.log(`‚úÖ Mail bildirimi '${status}' olarak olu≈üturuldu.`, { id: ref.id });

      return null;
    } catch (error) {
      console.error("Mail bildirimi olu≈üturulurken hata:", error);
      return null;
    }
  }
);

export const createMailNotificationOnDocumentStatusChangeV2 = onDocumentUpdated(
    {
        document: "unindexed_pdfs/{docId}",
        region: 'europe-west1'
    },
    async (event) => {
        const change = event.data;
        if (!change || !change.before || !change.after) {
          console.error("Unexpected Firestore event shape for onDocumentUpdated.", {
            hasChange: !!change,
            hasBefore: !!change?.before,
            hasAfter: !!change?.after,
          });
          return null;
        }
        const before = change.before.data() || {};
        const after  = change.after.data()  || {};
        const docId = event.params.docId;

        if (before.status !== 'indexed' && after.status === 'indexed') {
            console.log(`Belge indexlendi: ${docId}`, after);

            let rule = null;
            let template = null;
            let client = null;
            let status = "pending"; // Varsayƒ±lan durum
            let subject = "";
            let body = "";
            let ipRecordData = null;
            let applicants = [];
            var foundTransactionType = null;
            
            const associatedTransactionId = after.associatedTransactionId;
            if (associatedTransactionId) {
                try {
                    const ipRecordsSnapshot = await adminDb.collection("ipRecords").get();            
                    for (const ipDoc of ipRecordsSnapshot.docs) {
                        const transactionRef = db.collection("ipRecords").doc(ipDoc.id).collection("transactions").doc(associatedTransactionId);
                        const transactionDoc = await transactionRef.get();
                        if (transactionDoc.exists) {
                            ipRecordData = ipDoc.data();
                            applicants = ipRecordData.applicants || [];
                            foundTransactionType = transactionDoc.data()?.type;
                            console.log(`‚úÖ Transaction found in ipRecord: ${ipDoc.id}`);
                            break;
                        }
                    }
                    
                    if (ipRecordData) {
                        applicants = ipRecordData.applicants || [];
                        if (applicants.length > 0) {
                            const primaryApplicantId = applicants[0].id;
                            const clientSnapshot = await adminDb.collection("persons").doc(primaryApplicantId).get();
                            if (clientSnapshot.exists) {
                                client = clientSnapshot.data();
                            }
                        }
                    }
                } catch (error) {
                    console.error("Transaction sorgusu sƒ±rasƒ±nda hata:", error);
                }
            }

            const notificationType = after.mainProcessType || 'marka';
            const recipients = await getRecipientsByApplicantIds(applicants, notificationType);
            const toRecipients = recipients.to || [];
            const ccRecipients = new Set(recipients.cc || []);

            if (foundTransactionType) {
              const extraCc = await getCcFromEvrekaListByTransactionType(foundTransactionType);
              for (const e of extraCc) { ccRecipients.add(e); }
            }

            if (toRecipients.length === 0 && Array.from(ccRecipients).length === 0) {
                status = "missing_info";
            }

            if (!client && after.clientId) {
                const clientSnapshot = await adminDb.collection("persons").doc(after.clientId).get();
                if (clientSnapshot.exists) {
                    client = clientSnapshot.data();
                }
            }

            const rulesSnapshot = await adminDb.collection("template_rules")
                .where("sourceType", "==", "document")
                .where("mainProcessType", "==", after.mainProcessType)
                .where("subProcessType", "==", after.subProcessType)
                .limit(1)
                .get();

            if (!rulesSnapshot.empty) {
                rule = rulesSnapshot.docs[0].data();
                const templateSnapshot = await adminDb.collection("mail_templates").doc(rule.templateId).get();
                if (templateSnapshot.exists) {
                    template = templateSnapshot.data();
                }
            }

            if (template && client) {
                subject = template.subject;
                body = template.body;
                const parameters = { ...client, ...after };
                for (const key in parameters) {
                    const placeholder = new RegExp(`{{${key}}}`, "g");
                    subject = subject.replace(placeholder, parameters[key]);
                    body = body.replace(placeholder, parameters[key]);
                }
            } else {
                subject = "Eksik Bilgi: Bildirim Tamamlanamadƒ±";
                body = "Bu bildirim olu≈üturuldu ancak g√∂nderim i√ßin eksik bilgiler mevcut.";
                status = "missing_info";
            }

            const missingFields = [];
            if (!client) missingFields.push('client');
            if (!template) missingFields.push('template');
            if (toRecipients.length === 0 && Array.from(ccRecipients).length === 0) missingFields.push('recipients');

            // === YENƒ∞ DURUM VE ATAMA MANTIƒûI ===
            let finalStatus;
            if (missingFields.length > 0) {
                finalStatus = "missing_info";
            } else {
                finalStatus = "awaiting_client_approval"; // "pending" yerine bu durum kullanƒ±lƒ±r
            }

            const notificationData = {
                recipientTo: toRecipients,
                recipientCc: Array.from(ccRecipients),
                clientId: after.clientId || (applicants.length > 0 ? applicants[0].id : null),
                subject: subject,
                body: body,
                status: finalStatus, // G√úNCELLENDƒ∞
                missingFields: missingFields,
                sourceDocumentId: docId,
                notificationType: notificationType,
                
                // --- OTOMATƒ∞K ATAMA EKLENDƒ∞ ---
                assignedTo_uid: DEFAULT_ASSIGNEE_UID,
                assignedTo_email: DEFAULT_ASSIGNEE_EMAIL,
                // ----------------------------------

                createdAt: admin.firestore.FieldValue.serverTimestamp(),
                updatedAt: admin.firestore.FieldValue.serverTimestamp(),
            };

            await adminDb.collection("mail_notifications").add(notificationData);
            console.log(`Mail bildirimi '${finalStatus}' olarak olu≈üturuldu ve ${DEFAULT_ASSIGNEE_EMAIL} kullanƒ±cƒ±sƒ±na atandƒ±.`);
            return null;

        } else {
            console.log("Status deƒüi≈üimi indekslenme deƒüil, i≈ülem atlandƒ±.");
            return null;
        }
    }
);

export const createUniversalNotificationOnTaskCompleteV2 = onDocumentUpdated(
  {
    document: "tasks/{taskId}",
    region: "europe-west1",
  },
  async (event) => {
    const change = event.data;
    if (!change || !change.before || !change.after) return null;

    const before = change.before.data() || {};
    const after  = change.after.data() || {};
    const taskId = event.params.taskId;

    const becameCompleted = before.status !== "completed" && after.status === "completed";
    const epatsDoc = after?.details?.epatsDocument || null;
    if (!(becameCompleted && epatsDoc)) return null;

    const dedupe = (arr) => Array.from(new Set((arr || []).filter(Boolean).map((x) => String(x).trim())));
    const categoryKey = "marka";

    const findRecipientsFromPersonsRelated = async (personIds) => {
      const to = [], cc = [];
      if (!Array.isArray(personIds) || personIds.length === 0) return { to, cc };
      const chunks = [];
      for (let i = 0; i < personIds.length; i += 10) chunks.push(personIds.slice(i, i + 10));
      for (const chunk of chunks) {
        const prSnap = await adminDb.collection("personsRelated").where("personId", "in", chunk).get();
        prSnap.forEach((d) => {
          const pr = d.data();
          const email = (pr.email || "").trim();
          const isResp = pr?.responsible?.[categoryKey] === true;
          const n = pr?.notify?.[categoryKey] || {};
          if (email && isResp) {
            if (n?.to === true) to.push(email);
            if (n?.cc === true) cc.push(email);
          }
        });
      }
      return { to: dedupe(to), cc: dedupe(cc) };
    };

    const getRecipientsByApplicantIdsLocal = async (applicants) => {
      const ids = (Array.isArray(applicants) ? applicants : []).map(a => a?.id).filter(Boolean);
      return await findRecipientsFromPersonsRelated(ids);
    };

    let template = null, templateId = null, hasTemplate = false;
    try {
      const rulesSnap = await adminDb.collection("template_rules").where("sourceType", "==", "task_completion_epats").limit(1).get();
      if (!rulesSnap.empty) {
        const rule = rulesSnap.docs[0].data();
        templateId = rule?.templateId || null;
        if (templateId) {
          const tSnap = await adminDb.collection("mail_templates").doc(templateId).get();
          if (tSnap.exists) {
            template = tSnap.data();
            hasTemplate = true;
          }
        }
      }
    } catch (e) {
      console.warn("Template kuralƒ± aranƒ±rken hata:", e?.message || e);
    }

    let ipRecord = null;
    if (after.relatedIpRecordId) {
      try {
        const ipSnap = await adminDb.collection("ipRecords").doc(after.relatedIpRecordId).get();
        if (ipSnap.exists) ipRecord = ipSnap.data();
      } catch (e) {
        console.warn("IP kaydƒ± okunurken hata:", e?.message || e);
      }
    }

    const ownerIds = Array.isArray(after.taskOwner) ? after.taskOwner.filter(Boolean) : [];
    let toRecipients = [], ccRecipients = [], usedSource = null;

    if (ownerIds.length > 0) {
      usedSource = "taskOwner";
      const r = await findRecipientsFromPersonsRelated(ownerIds);
      toRecipients = r.to;
      ccRecipients = r.cc;
    } else {
      usedSource = "applicants_fallback";
      const r = await getRecipientsByApplicantIdsLocal(ipRecord?.applicants || []);
      toRecipients = r.to;
      ccRecipients = r.cc;
    }

    let txTypeForCc = null;
    try {
      const relatedIpId = after.relatedIpRecordId || null;
      const relatedTxId = after.relatedTransactionId || after.transactionId || null;
      if (relatedIpId && relatedTxId) {
        const txSnap = await adminDb.collection("ipRecords").doc(relatedIpId).collection("transactions").doc(relatedTxId).get();
        if (txSnap.exists) txTypeForCc = txSnap.data()?.type ?? null;
      }
      if (txTypeForCc == null && after.taskType != null) {
        txTypeForCc = after.taskType;
      }
      if (txTypeForCc != null) {
        const extra = await getCcFromEvrekaListByTransactionType(txTypeForCc);
        const allCcEmails = [...(ccRecipients || []), ...(extra || [])];
        ccRecipients = dedupe(allCcEmails);
      }
    } catch (e) {
      console.warn("CC listesi geni≈ületilirken hata:", e?.message || e);
    }

    let subject = "", body = "";
    if (hasTemplate) {
      subject = String(template.subject || "");
      body    = String(template.body || "");
      const parameters = {
        muvekkil_adi: "Bilinmeyen M√ºvekkil",
        is_basligi: after.title || "",
        epats_evrak_no: epatsDoc?.turkpatentEvrakNo || epatsDoc?.evrakNo || "",
        basvuru_no: ipRecord?.applicationNumber || after?.relatedIpRecordTitle || "",
      };
      subject = subject.replace(/{{\s*([\w.]+)\s*}}/g, (_, k) => parameters[k] ?? "");
      body    = body.replace(/{{\s*([\w.]+)\s*}}/g, (_, k) => parameters[k] ?? "");
    }

    // === YENƒ∞ DURUM VE ATAMA MANTIƒûI ===
    const coreMissing = [];
    if ((toRecipients.length + ccRecipients.length) === 0) coreMissing.push("recipients");
    if (!hasTemplate) coreMissing.push("mailTemplate");
    const finalStatus = coreMissing.length ? "missing_info" : "awaiting_client_approval";

    const epatsAttachment = {
      storagePath: epatsDoc?.storagePath || null,
      downloadURL: epatsDoc?.downloadURL || null,
      fileName:    epatsDoc?.name || "epats.pdf",
    };

    const notificationDoc = {
      toList: dedupe(toRecipients),
      ccList: dedupe(ccRecipients),
      subject,
      body,
      status: finalStatus, // G√úNCELLENDƒ∞
      missingFields: coreMissing,
      mode: "draft",
      isDraft: true,

      // --- OTOMATƒ∞K ATAMA EKLENDƒ∞ ---
      assignedTo_uid: DEFAULT_ASSIGNEE_UID,
      assignedTo_email: DEFAULT_ASSIGNEE_EMAIL,
      // ----------------------------------

      relatedIpRecordId: after.relatedIpRecordId || null,
      associatedTaskId:  taskId,
      associatedTransactionId: after.relatedTransactionId || after.transactionId || null,
      templateId: templateId || null,
      notificationType: "marka",
      source: usedSource,
      epatsAttachment,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    };

    await adminDb.collection("mail_notifications").add(notificationDoc);
    console.log(`Bildirim '${finalStatus}' olarak olu≈üturuldu ve ${DEFAULT_ASSIGNEE_EMAIL} kullanƒ±cƒ±sƒ±na atandƒ±.`);

    return null;
  }
);

// =========================================================
//              STORAGE TRIGGER FONKSƒ∞YONLARI (v2)
// =========================================================

// Trademark Bulletin Upload Processing (v2 Storage Trigger)
// Debug edilmi≈ü processTrademarkBulletinUploadV2 fonksiyonu
export const processTrademarkBulletinUploadV3 = onObjectFinalized(
  {
    region: "europe-west1",
    timeoutSeconds: 540,
    memory: "2GiB" // Bellek limiti artƒ±rƒ±ldƒ±
  },
  async (event) => {
    const filePath = event.data.name || "";
    const fileName = path.basename(filePath);

    // Sadece bulletins/ altƒ±ndaki ZIP dosyalarƒ±nƒ± i≈üle
    if (!filePath.startsWith("bulletins/") || !fileName.toLowerCase().endsWith(".zip")) {
      return null; // log atma
    }

    console.log("üî• Trademark Bulletin Upload V3 ba≈üladƒ±:", filePath);

    const bucket = admin.storage().bucket();
    const tempFilePath = path.join(os.tmpdir(), fileName);
    const extractDir = path.join(os.tmpdir(), `extract_${Date.now()}`);

    try {
      // ZIP indir
      await downloadWithStream(bucket.file(filePath), tempFilePath);

      // ZIP a√ß
      fs.mkdirSync(extractDir, { recursive: true });
      await extractZipStreaming(tempFilePath, extractDir);

      // Dosyalarƒ± tara
      const allFiles = listAllFilesRecursive(extractDir);

      // bulletin.inf oku
      const bulletinFile = allFiles.find((p) =>
        ["bulletin.inf", "bulletin"].includes(path.basename(p).toLowerCase())
      );
      if (!bulletinFile) throw new Error("bulletin.inf bulunamadƒ±.");

      const content = fs.readFileSync(bulletinFile, "utf8");
      const bulletinNo = (content.match(/NO\s*=\s*(.*)/) || [])[1]?.trim() || "Unknown";
      const bulletinDate = (content.match(/DATE\s*=\s*(.*)/) || [])[1]?.trim() || "Unknown";

      const bulletinRef = await adminDb.collection("trademarkBulletins").add({
        bulletinNo,
        bulletinDate,
        type: "marka",
        createdAt: admin.firestore.FieldValue.serverTimestamp()
      });
      const bulletinId = bulletinRef.id;

      console.log(`üìä B√ºlten kaydedildi: ${bulletinNo} (${bulletinDate}) ‚Üí ${bulletinId}`);

      // script parsing
      const scriptPath = allFiles.find(
        (p) => path.basename(p).toLowerCase() === "tmbulletin.log"
      );
      if (!scriptPath) throw new Error("tmbulletin.log bulunamadƒ±.");

      const records = await parseScriptContentStreaming(scriptPath);

      // IMAGE PATH OLU≈ûTURMA
      const imagesDir = allFiles.filter((p) => p.includes(path.sep + "images" + path.sep));
      const imagePathMap = {};
      for (const imgPath of imagesDir) {
        const filename = path.basename(imgPath);
        const match = filename.match(/^(\d{4})[_\-]?(\d{5,})/);
        if (match) {
          const appNo = `${match[1]}/${match[2]}`;
          if (!imagePathMap[appNo]) imagePathMap[appNo] = [];
          imagePathMap[appNo].push(
            `bulletins/trademark_${bulletinNo}_images/${filename}`
          );
        }
      }

      // **CHUNK UPLOAD - Bellek dostu**
      const CHUNK_SIZE = 200; // Aynƒ± anda en fazla 50 dosya
      for (let i = 0; i < imagesDir.length; i += CHUNK_SIZE) {
        const chunk = imagesDir.slice(i, i + CHUNK_SIZE);
        console.log(`üì¶ G√∂rsel chunk y√ºkleniyor: ${i + 1}-${i + chunk.length}/${imagesDir.length}`);

        await Promise.all(
          chunk.map((localPath) => {
            const destination = `bulletins/trademark_${bulletinNo}_images/${path.basename(localPath)}`;
            return bucket.upload(localPath, {
              destination,
              metadata: { contentType: getContentType(localPath) }
            });
          })
        );

        console.log(`‚úÖ Chunk tamamlandƒ± (${i + chunk.length}/${imagesDir.length})`);
        if (global.gc) {
          global.gc();
          console.log("üßπ Garbage collection tetiklendi (chunk sonrasƒ±)");
        }
      }

      console.log(`üì∑ ${imagesDir.length} g√∂rsel doƒürudan y√ºklendi`);

      // Firestore kayƒ±tlarƒ± (imagePath e≈üle≈ütirilmi≈ü)
      await writeBatchesToFirestore(records, bulletinId, bulletinNo,imagePathMap);

      console.log(
        `üéâ ZIP i≈üleme tamamlandƒ±: ${bulletinNo} ‚Üí ${records.length} kayƒ±t, ${imagesDir.length} g√∂rsel bulundu.`
      );
    } catch (e) {
      console.error("‚ùå Hata:", e.message);
      throw e;
    } finally {
      if (fs.existsSync(tempFilePath)) fs.unlinkSync(tempFilePath);
      if (fs.existsSync(extractDir)) fs.rmSync(extractDir, { recursive: true, force: true });
    }

    return null;
  }
);


// =========================================================
//              HELPER FONKSƒ∞YONLARI
// =========================================================

/**
 * IPRecord'daki applicants dizisindeki her ki≈üi i√ßin e-posta alƒ±cƒ±larƒ±nƒ± belirler
 * @param {Array} applicants IPRecord'daki applicants dizisi
 * @param {string} notificationType Bildirim t√ºr√º (√∂rn: 'marka')
 * @returns {Promise<{to: string[], cc: string[]}>} Alƒ±cƒ± listeleri
 */
// D√ºzeltilmi≈ü getRecipientsByApplicantIds fonksiyonu
async function getRecipientsByApplicantIds(applicants, notificationType = 'marka') {
  console.log("üöÄ getRecipientsByApplicantIds ba≈ülatƒ±ldƒ±");
  console.log("üìã Applicants:", applicants);
  console.log("üîç Notification type:", notificationType);
  
  const typeKey = notificationType === 'trademark' ? 'marka' : notificationType;
  console.log("üóùÔ∏è Type key:", typeKey);
  
  const toRecipients = new Set();
  const ccRecipients = new Set();
  
  const addEmails = (set, val, label) => {
    const arr = Array.isArray(val) ? val :
      (typeof val === 'string' ? [val] : []);
    for (const e of arr.map(x => String(x).trim()).filter(Boolean)) {
      set.add(e);
      console.log(`üìß ${label} eklendi: ${e}`);
    }
  };

  if (!Array.isArray(applicants) || applicants.length === 0) {
    console.warn("‚ùå Applicants dizisi bo≈ü veya null");
    return { to: [], cc: [] };
  }

  // Applicant ID'lerini topla
  const applicantIds = applicants
    .map(a => a?.id || a?.personId)
    .filter(Boolean);
  
  console.log("üìã Applicant ID'leri:", applicantIds);

  if (applicantIds.length === 0) {
    console.warn("‚ùå Ge√ßerli applicant ID'si bulunamadƒ±");
    return { to: [], cc: [] };
  }

  try {
    // T√úM personsRelated kayƒ±tlarƒ±nƒ± bul (applicant'lara ait olan)
    const prQuery = await adminDb.collection("personsRelated")
      .where("personId", "in", applicantIds)
      .get();

    console.log(`üìä Bulunan personsRelated kayƒ±t sayƒ±sƒ±: ${prQuery.docs.length}`);

    // Her personsRelated kaydƒ±nƒ± i≈üle
    for (const prDoc of prQuery.docs) {
      const pr = prDoc.data() || {};
      const personId = pr.personId;
      
      console.log(`\nüîç ƒ∞≈ülenen personsRelated kaydƒ± - PersonID: ${personId}`);
      console.log(`üìÑ Kayƒ±t ID: ${prDoc.id}`);
      
      // Bu ki≈üi bu notification type i√ßin responsible mƒ±?
      const isResponsible = pr?.responsible?.[typeKey] === true;
      console.log(`üîç responsible[${typeKey}] = ${String(isResponsible)}`);

      if (!isResponsible) {
        console.log(`‚ùå Person ${personId} sorumlu deƒüil - '${typeKey}' i√ßin`);
        continue;
      }

      // Notify ayarlarƒ±nƒ± al
      const ns = pr?.notify?.[typeKey] || {};
      console.log(`üîé notify[${typeKey}] =`, JSON.stringify(ns));

      // Email adresi al (personsRelated'deki email √∂ncelikli, yoksa persons'dan)
      let personEmail = (pr.email || '').trim();
      
      if (!personEmail) {
        // persons koleksiyonundan email al
        try {
          const personSnap = await adminDb.collection("persons").doc(personId).get();
          if (personSnap.exists) {
            const person = personSnap.data() || {};
            personEmail = (person.email || '').trim();
            console.log(`‚úÖ Person email bulundu: ${personEmail || '(yok)'}`);
          }
        } catch (err) {
          console.error(`‚ùå Person email alƒ±namadƒ± - ${personId}:`, err);
        }
      } else {
        console.log(`‚úÖ PersonsRelated email kullanƒ±lƒ±yor: ${personEmail}`);
      }

      // TO/CC ekleme i≈ülemleri
      if (personEmail) {
        if (ns.to === true) { 
          toRecipients.add(personEmail);  
          console.log(`üìß TO (${prDoc.id}): ${personEmail}`); 
        }
        if (ns.cc === true) { 
          ccRecipients.add(personEmail);  
          console.log(`üìß CC (${prDoc.id}): ${personEmail}`); 
        }
      } else {
        if (ns.to === true || ns.cc === true) {
          console.warn(`‚ö†Ô∏è Email eksik - PersonID: ${personId}, Record: ${prDoc.id}`);
        }
      }

      // Ek email listelerini ekle
      addEmails(toRecipients, ns.toList,   `TO (${prDoc.id}-toList)`);
      addEmails(toRecipients, ns.toEmails, `TO (${prDoc.id}-toEmails)`);
      if (Array.isArray(ns.to)) addEmails(toRecipients, ns.to, `TO (${prDoc.id}-to[])`);

      addEmails(ccRecipients, ns.ccList,   `CC (${prDoc.id}-ccList)`);
      addEmails(ccRecipients, ns.ccEmails, `CC (${prDoc.id}-ccEmails)`);
      if (Array.isArray(ns.cc)) addEmails(ccRecipients, ns.cc, `CC (${prDoc.id}-cc[])`);

      // Opsiyonel: personsRelated.emails[typeKey]
      const prEmails = pr?.emails?.[typeKey] || {};
      addEmails(toRecipients, prEmails.to, `TO (${prDoc.id}-pr.emails)`);
      addEmails(ccRecipients, prEmails.cc, `CC (${prDoc.id}-pr.emails)`);
    }

  } catch (err) {
    console.error("‚ùå personsRelated sorgu hatasƒ±:", err);
  }

  const result = { to: Array.from(toRecipients), cc: Array.from(ccRecipients) };
  console.log("üéØ FINAL RESULT:");
  console.log("üìß TO recipients:", result.to);
  console.log("üìß CC recipients:", result.cc);
  console.log("üìä TO count:", result.to.length);
  console.log("üìä CC count:", result.cc.length);
  return result;
}

/**
 * evrekaMailCCList koleksiyonundan CC adreslerini getirir.
 * - transactionTypes === "All" olanlarƒ±n hepsi
 * - transactionTypes array-contains <txType> olanlar
 * @param {number|string} txType
 * @returns {Promise<string[]>}
 */
async function getCcFromEvrekaListByTransactionType(txType) {
  console.log("üîç [EVREKA-CC] Fonksiyon √ßaƒürƒ±ldƒ±:", { txType, type: typeof txType });
  
  const emails = new Set();

  try {
    // 1) transactionTypes array'inde number arama
    const n = typeof txType === "number" ? txType : parseInt(txType, 10);
    console.log("üîç [EVREKA-CC] Parsed number:", { n, isValid: !Number.isNaN(n) });
    
    if (!Number.isNaN(n)) {
      const arrSnap = await adminDb.collection("evrekaMailCCList")
        .where("transactionTypes", "array-contains", n)
        .get();
      console.log(`üîç [EVREKA-CC] Number query sonu√ß: ${arrSnap.size} docs`);
      
      arrSnap.forEach(d => {
        const e = (d.data()?.email || "").trim();
        console.log(`‚úÖ [EVREKA-CC] Number match: ${d.id} -> ${e}`);
        if (e) emails.add(e);
      });
    }

    // 2) transactionTypes = "All" string deƒüeri olanlarƒ± ekle (== ile)
    const allSnap = await adminDb.collection("evrekaMailCCList")
      .where("transactionTypes", "==", "All")
      .get();
    console.log(`üîç [EVREKA-CC] "All" query sonu√ß: ${allSnap.size} docs`);
    
    allSnap.forEach(d => {
      const e = (d.data()?.email || "").trim();
      console.log(`‚úÖ [EVREKA-CC] "All" match: ${d.id} -> ${e}`);
      if (e) emails.add(e);
    });

    const result = Array.from(emails);
    console.log("üéØ [EVREKA-CC] Final result:", result);
    return result;
  } catch (err) {
    console.error("‚ùå [EVREKA-CC] evrekaMailCCList sorgu hatasƒ±:", err);
    return [];
  }
}
async function downloadWithStream(file, destination) {
  await pipeline(file.createReadStream(), fs.createWriteStream(destination));
}
async function extractZipStreaming(zipPath, extractDir) {
  const zip = new AdmZip(zipPath);
  const entries = zip.getEntries();
  for (const entry of entries) {
    if (entry.isDirectory) continue;
    const outputPath = path.join(extractDir, entry.entryName);
    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    fs.writeFileSync(outputPath, zip.readFile(entry));
  }
}
function listAllFilesRecursive(dir) {
  let results = [];
  const list = fs.readdirSync(dir);
  list.forEach((file) => {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);
    if (stat.isDirectory()) {
      results = results.concat(listAllFilesRecursive(fullPath));
    } else {
      results.push(fullPath);
    }
  });
  return results;
}
async function parseScriptContentStreaming(scriptPath) {
  const stats = fs.statSync(scriptPath);
  console.log(`üìè Script dosya boyutu: ${stats.size} bytes`);
  
  if (stats.size > 100 * 1024 * 1024) {
    console.log("üîÑ B√ºy√ºk dosya - chunk'lƒ± parsing kullanƒ±lƒ±yor");
    return parseScriptInChunks(scriptPath);
  }
  
  console.log("üîÑ Normal parsing kullanƒ±lƒ±yor");
  const content = fs.readFileSync(scriptPath, "utf8");
  return parseScriptContent(content);
}
function parseScriptContent(content) {
  console.log(`üîç Parse ba≈ülƒ±yor... Content length: ${content.length} karakter`);
  
  const recordsMap = {};
  const lines = content.split('\n');
  
  console.log(`üìù Toplam satƒ±r sayƒ±sƒ±: ${lines.length}`);
  
  let processedLines = 0;
  let insertCount = 0;
  let valuesParsed = 0;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    if (!line.length || !line.startsWith('INSERT INTO')) {
      continue;
    }
    
    processedLines++;
    insertCount++;
    
    if (processedLines % 1000 === 0) {
      console.log(`üìà ƒ∞≈ülenen satƒ±r: ${processedLines}/${lines.length}`);
    }
    
    // ESKƒ∞ √áALI≈ûAN REGEX PATTERN
    const match = line.match(/INSERT INTO (\w+) VALUES\s*\((.*)\)$/);
    if (!match) {
      if (insertCount <= 5) {
        console.warn(`‚ö†Ô∏è Regex e≈üle≈ümedi (satƒ±r ${i + 1}): ${line.substring(0, 100)}...`);
      }
      continue;
    }
    
    const table = match[1].toUpperCase();
    const valuesRaw = match[2];
    
    // MEVCUT parseValuesFromRaw FONKSƒ∞YONUNU KULLAN
    const values = parseValuesFromRaw(valuesRaw);
    
    if (!values || values.length === 0) {
      if (valuesParsed < 3) {
        console.warn(`‚ö†Ô∏è VALUES parse edilemedi: ${valuesRaw.substring(0, 50)}...`);
      }
      continue;
    }
    
    valuesParsed++;
    
    if (valuesParsed <= 3) {
      console.log(`‚úÖ Parse ba≈üarƒ±lƒ± (${table}):`, {
        appNo: values[0],
        totalValues: values.length,
        sample: values.slice(0, 3)
      });
    }
    
    const appNo = values[0];
    if (!appNo) continue;

    if (!recordsMap[appNo]) {
      recordsMap[appNo] = {
        applicationNo: appNo,
        applicationDate: null,
        markName: null,
        niceClasses: null,
        holders: [],
        goods: [],
        extractedGoods: [],
        attorneys: [],
      };
    }

    if (table === "TRADEMARK") {
      recordsMap[appNo].applicationDate = values[1] ?? null;
      recordsMap[appNo].markName = values[5] ?? null;
      recordsMap[appNo].niceClasses = values[6] ?? null;
    } else if (table === "HOLDER") {
      const holderName = extractHolderName(values[2]);
      let addressParts = [values[3], values[4], values[5], values[6]].filter(Boolean).join(", ");
      if (addressParts.trim() === "") addressParts = null;
      recordsMap[appNo].holders.push({
        name: holderName,
        address: addressParts,
        country: values[7] ?? null,
      });
    } else if (table === "GOODS") {
      recordsMap[appNo].goods.push(values[3] ?? null);
    } else if (table === "EXTRACTEDGOODS") {
      recordsMap[appNo].extractedGoods.push(values[3] ?? null);
    } else if (table === "ATTORNEY") {
      recordsMap[appNo].attorneys.push(values[2] ?? null);
    }
  }
  
  const result = Object.values(recordsMap);
  
  console.log(`‚úÖ Parse tamamlandƒ±:`, {
    totalLines: lines.length,
    processedLines: processedLines,
    insertCount: insertCount,
    valuesParsed: valuesParsed,
    uniqueApplications: result.length,
    successRate: insertCount > 0 ? ((valuesParsed / insertCount) * 100).toFixed(1) + '%' : '0%'
  });
  
  if (result.length > 0) {
    console.log(`üìã ƒ∞lk kayƒ±t √∂rneƒüi:`, JSON.stringify(result[0], null, 2));
  }
  
  return result;
}
function parseValuesFromRaw(raw) {
  const values = [];
  let current = "";
  let inString = false;
  let i = 0;

  while (i < raw.length) {
    const char = raw[i];
    if (char === "'") {
      if (inString && raw[i + 1] === "'") {
        current += "'";
        i += 2;
        continue;
      } else {
        inString = !inString;
      }
    } else if (char === "," && !inString) {
      values.push(decodeValue(current.trim()));
      current = "";
      i++;
      continue;
    } else {
      current += char;
    }
    i++;
  }
  
  if (current.trim()) {
    values.push(decodeValue(current.trim()));
  }
  
  return values;
}

async function parseScriptInChunks(scriptPath) {
  const fd = fs.openSync(scriptPath, "r");
  const fileSize = fs.statSync(scriptPath).size;
  const chunkSize = 1024 * 1024;
  let buffer = "";
  let position = 0;
  const records = {};
  let currentTable = null;
  while (position < fileSize) {
    const chunk = Buffer.alloc(Math.min(chunkSize, fileSize - position));
    fs.readSync(fd, chunk, 0, chunk.length, position);
    position += chunk.length;
    buffer += chunk.toString("utf8");
    const lines = buffer.split("\n");
    buffer = lines.pop() || "";
    for (const line of lines) {
      if (line.startsWith("INSERT INTO")) {
        const match = line.match(/INSERT INTO (\w+)/);
        currentTable = match ? match[1] : null;
      }
      if (currentTable && line.includes("VALUES")) {
        const values = parseValuesFromLine(line);
        if (!values || !values.length) continue;
        const appNo = values[0];
        if (!records[appNo]) {
          records[appNo] = {
            applicationNo: appNo,
            applicationDate: null,
            markName: null,
            niceClasses: null,
            holders: [],
            goods: [],
            extractedGoods: [],
            attorneys: []
          };
        }
        if (currentTable === "TRADEMARK") {
          records[appNo].applicationDate = values[1] || null;
          records[appNo].markName = values[4] || null;
          records[appNo].niceClasses = values[6] || null;
        } else if (currentTable === "HOLDER") {
          records[appNo].holders.push({
            name: extractHolderName(values[2]),
            address: values[3],
            country: values[4]
          });
        } else if (currentTable === "GOODS") {
          records[appNo].goods.push(values[3]);
        } else if (currentTable === "EXTRACTEDGOODS") {
          records[appNo].extractedGoods.push(values[3]);
        } else if (currentTable === "ATTORNEY") {
          records[appNo].attorneys.push(values[2]);
        }
      }
    }
  }
  fs.closeSync(fd);
  return Object.values(records);
}
function parseValuesFromLine(line) {
  const valuesMatch = line.match(/VALUES\s*\((.*)\)/i);
  if (!valuesMatch) return null;
  
  return parseValuesFromRaw(valuesMatch[1]);
}
function decodeValue(str) {
    if (str === null || str === undefined) return null;
    if (str === "") return null;
    str = str.replace(/^'/, "").replace(/'$/, "").replace(/''/g, "'");
    // \uXXXX formatƒ±ndaki unicode karakterleri √ß√∂z
    return str.replace(/\\u([0-9a-fA-F]{4})/g,
        (m, g1) => String.fromCharCode(parseInt(g1, 16))
    );
}
function extractHolderName(str) {
  if (!str) return null;
  const parenMatch = str.match(/^\(\d+\)\s*(.*)$/);
  return parenMatch ? parenMatch[1].trim() : str.trim();
}
async function writeBatchesToFirestore(records, bulletinId, bulletinNo, imagePathMap) {
  const batchSize = 250;
  for (let i = 0; i < records.length; i += batchSize) {
    const chunk = records.slice(i, i + batchSize);
    const batch = db.batch();
    chunk.forEach((record) => {
      record.bulletinId = bulletinId;
      record.bulletinNo = bulletinNo;
      const matchingImages = imagePathMap[record.applicationNo] || [];
      record.imagePath = matchingImages.length > 0 ? matchingImages[0] : null;
      record.imageUploaded = false;
      batch.set(db.collection("trademarkBulletinRecords").doc(), {
        ...record,
        createdAt: admin.firestore.FieldValue.serverTimestamp()
      });
    });
    await batch.commit();
    console.log(`üìù ${Math.min(i + batchSize, records.length)}/${records.length} kayƒ±t yazƒ±ldƒ±`);
  }
}

function getContentType(filePath) {
  if (/\.png$/i.test(filePath)) return "image/png";
  if (/\.jpe?g$/i.test(filePath)) return "image/jpeg";
  return "application/octet-stream";
}

// B√úLTEN Sƒ∞LME 
export const deleteBulletinV2 = onCall(
  { timeoutSeconds: 60, memory: "1GiB", region: "europe-west1" },
  async (request) => {
    try {
      const { bulletinId } = request.data || {};
      if (!bulletinId) {
        throw new HttpsError('invalid-argument', 'BulletinId gerekli.');
      }

      console.log(`üóëÔ∏è Silme i≈ülemi ba≈ülatƒ±lƒ±yor: ${bulletinId}`);

      const operationId = `delete_${bulletinId}_${Date.now()}`;
      const statusRef = db.collection('operationStatus').doc(operationId);
      
      // ƒ∞lk durumu kaydet
      await statusRef.set({
        operationId,
        bulletinId,
        status: 'queued',
        message: 'Silme kuyruƒüa alƒ±ndƒ±...',
        progress: 0,
        startTime: admin.firestore.FieldValue.serverTimestamp(),
        userId: request.auth?.uid || null
      });

      console.log(`‚úÖ Operation status created: ${operationId}`);

      // Topic olu≈ütur/kontrol et
      try {
        await ensureTopic('bulletin-deletion');
        console.log('‚úÖ Topic ensured: bulletin-deletion');
      } catch (topicError) {
        console.error('‚ùå Topic creation failed:', topicError);
        await statusRef.update({
          status: 'error',
          message: `Topic olu≈üturulamadƒ±: ${topicError.message}`,
          endTime: admin.firestore.FieldValue.serverTimestamp()
        });
        throw new HttpsError('internal', `Topic olu≈üturulamadƒ±: ${topicError.message}`);
      }

      // Pub/Sub mesajƒ±nƒ± yayƒ±nla
      try {
        const messageId = await pubsubClient.topic('bulletin-deletion').publishMessage({
          json: { bulletinId, operationId }
        });
        console.log(`‚úÖ Pub/Sub message published: ${messageId}`);
        
        await statusRef.update({
          message: 'Mesaj kuyruƒüa g√∂nderildi, i≈ülem ba≈ülatƒ±lƒ±yor...',
          progress: 5,
          pubsubMessageId: messageId
        });
        
      } catch (publishError) {
        console.error('‚ùå Pub/Sub publish failed:', publishError);
        await statusRef.update({
          status: 'error',
          message: `Mesaj g√∂nderilemedi: ${publishError.message}`,
          endTime: admin.firestore.FieldValue.serverTimestamp()
        });
        throw new HttpsError('internal', `Mesaj g√∂nderilemedi: ${publishError.message}`);
      }

      return { success: true, operationId, message: 'Silme i≈ülemi kuyruƒüa alƒ±ndƒ±.' };
    } catch (error) {
      console.error('‚ùå deleteBulletinV2 error:', error);
      if (error instanceof HttpsError) {
        throw error;
      }
      throw new HttpsError('internal', String(error?.message || error));
    }
  }
);

// Ger√ßek silme i≈ülemini yapan fonksiyon
async function performBulletinDeletion(bulletinId, operationId) {
  const statusRef = db.collection('operationStatus').doc(operationId);
  
  try {
    console.log(`üî• Ger√ßek silme i≈ülemi ba≈üladƒ±: ${bulletinId}`);
    
    // === 1. B√ºlten dok√ºmanƒ±nƒ± al ===
    const bulletinDoc = await db.collection('trademarkBulletins').doc(bulletinId).get();
    if (!bulletinDoc.exists) {
      throw new Error('B√ºlten bulunamadƒ±.');
    }

    const bulletinData = bulletinDoc.data();
    const bulletinNo = bulletinData.bulletinNo;
    console.log(`üìã Silinecek b√ºlten: ${bulletinNo}`);

    await statusRef.update({
      status: 'in_progress',
      message: `B√ºlten ${bulletinNo} kayƒ±tlarƒ± siliniyor...`,
      progress: 10
    });

    // === 2. ƒ∞li≈ükili trademarkBulletinRecords silme (BulkWriter, hƒ±zlƒ±) ===
    let totalRecordsDeleted = 0;

    // Sadece referans/id yeterli; network y√ºk√ºn√º azaltmak i√ßin select() kullan
    const baseQuery = db.collection('trademarkBulletinRecords')
      .where('bulletinId', '==', bulletinId)
      .select();

    const writer = admin.firestore().bulkWriter({
      throttling: { initialOpsPerSecond: 500, maxOpsPerSecond: 2000 }
    });

    let lastDoc = null;
    while (true) {
      let q = baseQuery.limit(1000);
      if (lastDoc) q = q.startAfter(lastDoc);

      const snap = await q.get();
      if (snap.empty) break;

      for (const d of snap.docs) {
        writer.delete(d.ref);
      }
      totalRecordsDeleted += snap.size;
      lastDoc = snap.docs[snap.docs.length - 1];

      console.log(`‚úÖ ${totalRecordsDeleted} kayƒ±t silme kuyruƒüa alƒ±ndƒ±`);

      // ƒ∞lerlemeyi g√ºncelle (80'e kadar)
      await statusRef.update({
        message: `${totalRecordsDeleted} kayƒ±t siliniyor...`,
        progress: Math.min(30 + Math.floor(totalRecordsDeleted / 100), 80)
      });
    }

    // Kuyruƒüun bitmesini bekle
    await writer.close();
    console.log(`‚úÖ Toplam silinen kayƒ±t: ${totalRecordsDeleted}`);

    await statusRef.update({
      message: 'Storage dosyalarƒ± siliniyor...',
      progress: 85
    });

  // === 3. Storage'dan g√∂rselleri sil (hƒ±zlƒ±, toplu) ===
  let totalImagesDeleted = 0;
  try {
    const bucket = admin.storage().bucket();

    // Y√ºkleme ile uyumlu ger√ßek klas√∂r + ge√ßmi≈ü/yanlƒ±≈ü path i√ßin ek prefix
    const prefixes = [
      `bulletins/trademark_${bulletinNo}_images/`,
      `trademark_images/${bulletinNo}/`
    ];

    for (const pfx of prefixes) {
      try {
        // √ñnce sayƒ±yƒ± √∂l√ß (log/istatistik i√ßin), sonra toplu sil
        const [files] = await bucket.getFiles({ prefix: pfx });
        if (files.length > 0) {
          console.log(`üñºÔ∏è ${pfx} altƒ±nda ${files.length} dosya bulundu ‚Äî toplu siliniyor...`);
          await bucket.deleteFiles({ prefix: pfx, force: true }); // ‚úÖ √ßok daha hƒ±zlƒ±
          totalImagesDeleted += files.length;
          console.log(`‚úÖ ${pfx} temizlendi`);
        } else {
          console.log(`‚ÑπÔ∏è ${pfx} altƒ±nda dosya yok`);
        }
      } catch (delErr) {
        console.warn(`‚ö†Ô∏è ${pfx} temizleme hatasƒ±:`, delErr?.message || delErr);
      }
    }
  } catch (storageError) {
    console.warn('‚ö†Ô∏è Storage silme hatasƒ±:', storageError?.message || storageError);
  }

  await statusRef.update({
    message: 'Ana b√ºlten kaydƒ± siliniyor...',
    progress: 95
  });

    // === 4. Ana b√ºlten dok√ºmanƒ±nƒ± sil ===
    await bulletinDoc.ref.delete();
    
    // === 5. Ba≈üarƒ± durumunu g√ºncelle ===
    await statusRef.update({
      status: 'completed',
      message: `B√ºlten ${bulletinNo} ba≈üarƒ±yla silindi! Kayƒ±tlar: ${totalRecordsDeleted}, G√∂rseller: ${totalImagesDeleted}`,
      progress: 100,
      endTime: admin.firestore.FieldValue.serverTimestamp(),
      recordsDeleted: totalRecordsDeleted,
      imagesDeleted: totalImagesDeleted
    });

    console.log(`üéâ B√ºlten ${bulletinNo} ba≈üarƒ±yla silindi!`);
    
  } catch (error) {
    console.error('‚ùå Silme i≈ülemi hatasƒ±:', error);
    
    await statusRef.update({
      status: 'error',
      message: `Hata: ${error.message}`,
      endTime: admin.firestore.FieldValue.serverTimestamp()
    });
  }
}

// Bu mod√ºllerin functions/ altƒ±nda da bulunmasƒ± veya fonksiyon i√ßine ta≈üƒ±nmasƒ± gerekecek.
// ≈ûimdilik varsayƒ±msal olarak import edeceƒüiz ve deployment sƒ±rasƒ±nda d√ºzenleme gerekebilir.
// Eƒüer bu helper dosyalarƒ±nƒ± (preprocess, visual-match, phonetic) functions klas√∂r√ºne kopyalamazsanƒ±z,
// a≈üaƒüƒ±daki import yollarƒ±nƒ± Node.js ortamƒ±na uygun olarak ayarlamanƒ±z veya bu kodlarƒ± doƒürudan bu dosya i√ßine ta≈üƒ±manƒ±z gerekebilir.
// En temiz y√∂ntem, bu helper'larƒ± functions klas√∂r√ºn√ºn altƒ±nda ayrƒ± bir utils veya helperlar klas√∂r√ºne ta≈üƒ±maktƒ±r.
// ≈ûimdilik fonksiyonun i√ßine doƒürudan kopyalayacaƒüƒ±m ki ek dosya baƒüƒ±mlƒ±lƒ±ƒüƒ± olmasƒ±n.


// ======== Yardƒ±mcƒ± Fonksiyonlar ve Algoritmalar (scorer.js, preprocess.js, visual-match.js, phonetic.js'ten kopyalandƒ±) ========

// GENERIC_WORDS (preprocess.js'ten kopyalandƒ±)
const GENERIC_WORDS = [// ======== ≈ûƒ∞RKET Tƒ∞PLERƒ∞ ========
    'ltd', '≈üti', 'a≈ü', 'anonim', '≈üirketi', '≈üirket', 'limited', 'inc', 'corp', 'corporation', 'co', 'company', 'llc', 'group', 'grup',

    // ======== Tƒ∞CARƒ∞ SEKT√ñRLER ========
    'sanayi', 'ticaret', 'turizm', 'tekstil', 'gƒ±da', 'in≈üaat', 'danƒ±≈ümanlƒ±k', 'hizmet', 'hizmetleri', 'bili≈üim', 'teknoloji', 'sigorta', 'yayƒ±ncƒ±lƒ±k', 'mobilya', 'otomotiv', 'tarƒ±m', 'enerji', 'petrol', 'kimya', 'kozmetik', 'ila√ß', 'medikal', 'saƒülƒ±k', 'eƒüitim', 'spor', 'm√ºzik', 'film', 'medya', 'reklam', 'pazarlama', 'lojistik', 'nakliyat', 'kargo', 'finans', 'bankacƒ±lƒ±k', 'emlak', 'gayrimenkul', 'madencilik', 'metal', 'plastik', 'cam', 'seramik', 'ah≈üap',

    // ======== MESLEKƒ∞ TERƒ∞MLER ========
    'm√ºhendislik', 'proje', 'taahh√ºt', 'ithalat', 'ihracat', '√ºretim', 'imalat', 'veteriner', 'petshop', 'polikliniƒüi', 'hastane', 'klinik', 'm√º≈üavirlik', 'muhasebe', 'hukuk', 'avukatlƒ±k', 'mimarlƒ±k', 'peyzaj', 'tasarƒ±m', 'dizayn', 'design', 'grafik', 'web', 'yazƒ±lƒ±m', 'software', 'donanƒ±m', 'hardware', 'elektronik', 'elektrik', 'makina', 'makine', 'end√ºstri', 'fabrika', 'laboratuvar', 'ara≈ütƒ±rma', 'geli≈ütirme', 'ofis', // 'ofis' eklendi

    // ======== √úR√úN/Hƒ∞ZMET TERƒ∞MLERƒ∞ ========
    '√ºr√ºn', // '√ºr√ºn' k√∂k√º eklendi (√ºr√ºnleri, √ºr√ºnler gibi varyasyonlarƒ± kapsayacak)
    'products', 'services', 'solutions', '√ß√∂z√ºm', // '√ß√∂z√ºmleri' yerine '√ß√∂z√ºm' k√∂k√º
    'sistem', 'systems', 'teknolojileri', 'teknoloji', // 'teknolojileri' yanƒ±na 'teknoloji'
    'malzeme', 'materials', 'ekipman', 'equipment', 'cihaz', 'device', 'ara√ß', 'tools', 'yedek', 'par√ßa', 'parts', 'aksesuar', 'accessories', 'gere√ß', 'malzeme',

    // ======== GENEL MARKALA≈ûMA TERƒ∞MLERƒ∞ ========
    'me≈ühur', '√ºnl√º', 'famous', 'since', 'est', 'established', 'tarihi', 'historical', 'geleneksel', 'traditional', 'klasik', 'classic', 'yeni', 'new', 'fresh', 'taze', '√∂zel', 'special', 'premium', 'l√ºks', 'luxury', 'kalite', // 'kalite' eklendi
    'quality', 'uygun', // 'uygun' eklendi

    // ======== LOKASYON TERƒ∞MLERƒ∞ ========
    'turkey', 't√ºrkiye', 'international', 'uluslararasƒ±',

    // ======== EMLAK TERƒ∞MLERƒ∞ ========
    'realestate', 'emlak', 'konut', 'housing', 'arsa', 'ticari', 'commercial', 'ofis', 'office', 'plaza', 'shopping', 'alƒ±≈üveri≈ü', 'residence', 'rezidans', 'villa', 'apartment', 'daire',

    // ======== Dƒ∞Jƒ∞TAL TERƒ∞MLERƒ∞ ========
    'online', 'digital', 'dijital', 'internet', 'web', 'app', 'mobile', 'mobil', 'network', 'aƒü', 'server', 'sunucu', 'hosting', 'domain', 'platform', 'social', 'sosyal', 'media', 'medya',

    // ======== GIDA TERƒ∞MLERƒ∞ ========
    'gƒ±da', 'food', 'yemek', 'restaurant', 'restoran', 'cafe', 'kahve', 'coffee', '√ßay', 'tea', 'fƒ±rƒ±n', 'bakery', 'ekmek', 'bread', 'pasta', 'b√∂rek', 'pizza', 'burger', 'kebap', 'd√∂ner', 'pide', 'lahmacun', 'balƒ±k', 'fish', 'et', 'meat', 'tavuk', 'chicken', 'sebze', 'vegetable', 'meyve', 'fruit', 's√ºt', 'milk', 'peynir', 'cheese', 'yoƒüurt', 'yogurt', 'dondurma', '≈üeker', 'sugar', 'bal', 're√ßel', 'jam', 'konserve', 'canned', 'organic', 'organik', 'doƒüal', 'natural', 'taze', 'fresh',

    // ======== BAƒûLA√áLAR ve Yaygƒ±n Kelimeler ========
    've', 'ile', 'i√ßin', 'bir', 'bu', 'da', 'de', 'ki', 'mi', 'mƒ±', 'mu', 'm√º',
    'sadece', 'tek', 'en', '√ßok', 'az', '√ºst', 'alt', 'yeni', 'eski'
];

function removeTurkishSuffixes(word) {
    if (!word) return '';
    
    // √áoƒüul ekleri: -ler, -lar
    if (word.endsWith('ler') || word.endsWith('lar')) {
        return word.substring(0, word.length - 3);
    }
    // ƒ∞yelik ekleri (basit formlar): -im, -in, -i, -ƒ±mƒ±z, -ƒ±nƒ±z, -larƒ±
    // √ñrneƒüin, 'ofisi' -> 'ofis'
    if (word.endsWith('si') || word.endsWith('sƒ±') || word.endsWith('s√º') || word.endsWith('su')) {
        return word.substring(0, word.length - 2);
    }
    if (word.endsWith('i') || word.endsWith('ƒ±') || word.endsWith('u') || word.endsWith('√º')) {
        // 'gƒ±da' gibi kelimelerde 'ƒ±' son ek olmamalƒ±, bu y√ºzden dikkatli olmalƒ±
        // Daha g√ºvenli bir kontrol i√ßin kelime k√∂k√º kontrol edilebilir
        // ≈ûimdilik sadece iyelik ve y√∂nelme eklerini √ßƒ±karƒ±yoruz.
        // Basit√ße son harfi kaldƒ±rmak riskli, ama ≈üimdilik en yaygƒ±n olanlarƒ± ele alalƒ±m
        if (word.length > 2 && ['i', 'ƒ±', 'u', '√º'].includes(word[word.length - 1])) {
             // 'ofis' gibi kelimelerde 'i' iyelik eki olabilir.
             // Daha sofistike bir √ß√∂z√ºm i√ßin NLP k√ºt√ºphanesi gerekir, bu basit bir yakla≈üƒ±mdƒ±r.
             return word.substring(0, word.length - 1);
        }
    }
    // Fiilimsiler, durum ekleri vb. i√ßin daha karma≈üƒ±k kurallar gerekebilir
    
    return word;
}

/**
 * Marka adƒ±nƒ± temizler: k√º√ß√ºk harfe √ßevirir, √∂zel karakterleri kaldƒ±rƒ±r, stopwords'√º √ßƒ±karƒ±r.
 *
 * @param {string} name Marka adƒ±
 * @param {boolean} removeGenericWords Stopwords'√ºn √ßƒ±karƒ±lƒ±p √ßƒ±karƒ±lmayacaƒüƒ±nƒ± belirler.
 * Genellikle √ßok kelimeli isimler i√ßin true olmalƒ±.
 * @returns {string} Temizlenmi≈ü marka adƒ±.
 */
export function cleanMarkName(name, removeGenericWords = true) {
    if (!name) return '';
    let cleaned = name.toLowerCase().replace(/[^a-z0-9ƒü√º≈ü√∂√ßƒ±\s]/g, '').trim(); // Harf, rakam ve bo≈üluk dƒ±≈üƒ±ndaki her ≈üeyi kaldƒ±r

    // Birden fazla bo≈üluƒüu tek bo≈üluƒüa indirge
    cleaned = cleaned.replace(/\s+/g, ' ');

    if (removeGenericWords) {
        // Kelimelere ayƒ±r, eklerini kaldƒ±r ve stopwords olmayanlarƒ± filtrele
        cleaned = cleaned.split(' ').filter(word => {
            const stemmedWord = removeTurkishSuffixes(word);
            // K√∂k kelime veya orijinal kelime stopwords listesinde mi kontrol et
            return !GENERIC_WORDS.includes(stemmedWord) && !GENERIC_WORDS.includes(word);
        }).join(' ');
    }

    return cleaned.trim();
}

// visual-match.js'ten kopyalandƒ±
const visualMap = {
    "a": ["e", "o"], "b": ["d", "p"], "c": ["√ß", "s"], "√ß": ["c", "s"], "d": ["b", "p"], "e": ["a", "o"], "f": ["t"],
    "g": ["ƒü", "q"], "ƒü": ["g", "q"], "h": ["n"], "i": ["l", "j", "ƒ±"], "ƒ±": ["i"], "j": ["i", "y"], "k": ["q", "x"],
    "l": ["i", "1"], "m": ["n"], "n": ["m", "r"], "o": ["a", "0", "√∂"], "√∂": ["o"], "p": ["b", "q"], "q": ["g", "k"],
    "r": ["n"], "s": ["≈ü", "c", "z"], "≈ü": ["s", "z"], "t": ["f"], "u": ["√º", "v"], "√º": ["u", "v"], "v": ["u", "√º", "w"],
    "w": ["v"], "x": ["ks"], "y": ["j"], "z": ["s", "≈ü"], "0": ["o"], "1": ["l", "i"], "ks": ["x"], "Q": ["O","0"],
    "O": ["Q", "0"], "I": ["l", "1"], "L": ["I", "1"], "Z": ["2"], "S": ["5"], "B": ["8"], "D": ["O"]
};

function visualMismatchPenalty(a, b) {
    if (!a || !b) return 5; 

    const lenDiff = Math.abs(a.length - b.length);
    const minLen = Math.min(a.length, b.length);
    let penalty = lenDiff * 0.5;

    for (let i = 0; i < minLen; i++) {
        const ca = a[i].toLowerCase();
        const cb = b[i].toLowerCase();

        if (ca !== cb) {
            if (visualMap[ca] && visualMap[ca].includes(cb)) {
                penalty += 0.25;
            } else {
                penalty += 1.0;
            }
        }
    }
    return penalty;
}

// phonetic.js'ten kopyalandƒ±
function normalizeString(str) {
    if (!str) return "";
    return str
        .toLowerCase()
        .replace(/[^a-z0-9ƒü√º≈ü√∂√ßƒ±]/g, '')
        .replace(/ƒü/g, 'g')
        .replace(/√º/g, 'u')
        .replace(/≈ü/g, 's')
        .replace(/√∂/g, 'o')
        .replace(/√ß/g, 'c')
        .replace(/ƒ±/g, 'i');
}

function isPhoneticallySimilar(a, b) {
    if (!a || !b) return 0.0;

    a = normalizeString(a);
    b = normalizeString(b);

    if (a === b) return 1.0;

    const lenA = a.length;
    const lenB = b.length;
    const minLen = Math.min(lenA, lenB);
    const maxLen = Math.max(lenA, lenB);

    if (maxLen === 0) return 1.0;
    if (maxLen > 0 && minLen === 0) return 0.0;

    const lengthMismatchPenalty = Math.abs(lenA - lenB) / maxLen;
    let score = 1.0 - lengthMismatchPenalty;

    let matchingChars = 0;
    const matchedA = new Array(lenA).fill(false);
    const matchedB = new Array(lenB).fill(false);

    const searchRange = Math.min(maxLen, Math.floor(maxLen / 2) + 1);
    for (let i = 0; i < lenA; i++) {
        for (let j = Math.max(0, i - searchRange); j < Math.min(lenB, i + searchRange + 1); j++) {
            if (a[i] === b[j] && !matchedB[j]) {
                matchingChars++;
                matchedA[i] = true;
                matchedB[j] = true;
                break;
            }
        }
    }

    if (matchingChars === 0) return 0.0;

    const commonality = matchingChars / Math.max(lenA, lenB);
    
    let positionalBonus = 0;
    if (lenA > 0 && lenB > 0) {
        if (a[0] === b[0]) positionalBonus += 0.2;
        if (lenA > 1 && lenB > 1 && a[1] === b[1]) positionalBonus += 0.1;
    }

    score = (commonality * 0.7) + (positionalBonus * 0.3);

    return Math.max(0.0, Math.min(1.0, score));
}
function parseDate(value) {
  if (!value) return null;
  
  // dd/MM/yyyy formatƒ± desteƒüi (T√ºrkiye standartƒ±)
  const parts = value.split('/');
  if (parts.length === 3) {
    const day = parseInt(parts[0], 10);
    const month = parseInt(parts[1], 10) - 1; // 0-indexed
    const year = parseInt(parts[2], 10);
    
    // Ge√ßerlilik kontrol√º ekleyin
    if (day > 0 && day <= 31 && month >= 0 && month <= 11 && year > 1900) {
      return new Date(year, month, day);
    }
  }
  
  // ISO formatƒ± veya ba≈üka formatlar i√ßin
  const isoDate = new Date(value);
  return isNaN(isoDate) ? null : isoDate;
}

function isValidBasedOnDate(hitDate, monitoredDate) {
  if (!hitDate || !monitoredDate) return true;

  const hit = parseDate(hitDate);
  const monitored = parseDate(monitoredDate);

  if (!hit || !monitored || isNaN(hit) || isNaN(monitored)) return true;

  // doƒüru mantƒ±k
  return hit >= monitored;
}

// functions/index.js - D√ºzeltilmi≈ü nice sƒ±nƒ±f fonksiyonu

function hasOverlappingNiceClasses(monitoredTrademark, bulletinRecordNiceClasses) {
  logger.log("üè∑Ô∏è Nice sƒ±nƒ±f kar≈üƒ±la≈ütƒ±rmasƒ±:", {
    monitoredTrademarkId: monitoredTrademark.id,
    monitoredNiceClassSearch: monitoredTrademark.niceClassSearch,
    bulletinRecordNiceClasses,
    bulletinRecordType: typeof bulletinRecordNiceClasses
  });
  
  try {
    // ƒ∞zlenen markadan niceClassSearch array'ini al
    const monitoredNiceClassSearch = monitoredTrademark.niceClassSearch || [];
    
    // Eƒüer izlenen markanƒ±n niceClassSearch'u yoksa, sƒ±nƒ±f filtresini atla
    if (!Array.isArray(monitoredNiceClassSearch) || monitoredNiceClassSearch.length === 0) {
      logger.log("‚ÑπÔ∏è ƒ∞zlenen markanƒ±n niceClassSearch'u yok, filtre atlanƒ±yor");
      return true;
    }
    
    // B√ºlten kaydƒ±nda nice sƒ±nƒ±f yoksa √ßakƒ±≈üma yok
    if (!bulletinRecordNiceClasses) {
      logger.log("‚ÑπÔ∏è B√ºlten kaydƒ±nda nice sƒ±nƒ±f yok, √ßakƒ±≈üma yok");
      return false;
    }

    // Nice sƒ±nƒ±flarƒ± normalize et (sadece rakamlarƒ± al ve array'e √ßevir)
    const normalizeNiceClasses = (classes) => {
      if (!classes) return [];
      
      let classArray = [];
      
      if (Array.isArray(classes)) {
        classArray = classes;
      } else if (typeof classes === 'string') {
        // String ise √∂nce " / " ile b√∂l, sonra diƒüer ayƒ±rƒ±cƒ±larla da b√∂l
        classArray = classes.split(/[\s\/,]+/).filter(c => c.trim());
      } else {
        classArray = [String(classes)];
      }
      
      // Her sƒ±nƒ±ftan sadece rakamlarƒ± al
      return classArray
        .map(cls => String(cls).replace(/\D/g, '')) // Sadece rakamlarƒ± al
        .filter(cls => cls && cls.length > 0); // Bo≈ü olanlarƒ± √ßƒ±kar
    };
    
    const monitoredClasses = normalizeNiceClasses(monitoredNiceClassSearch);
    const bulletinRecordClasses = normalizeNiceClasses(bulletinRecordNiceClasses);
    
    logger.log("üîß Normalize edilmi≈ü sƒ±nƒ±flar:", {
      monitoredClasses: monitoredClasses,
      bulletinRecordClasses: bulletinRecordClasses
    });
    
    // B√ºlten kaydƒ± sƒ±nƒ±flarƒ± bo≈üsa √ßakƒ±≈üma yok
    if (bulletinRecordClasses.length === 0) {
      logger.log("‚ÑπÔ∏è B√ºlten kaydƒ± sƒ±nƒ±flarƒ± bo≈ü, √ßakƒ±≈üma yok");
      return false;
    }
    
    // Kesi≈üim kontrol√º
    const hasOverlap = monitoredClasses.some(monitoredClass => 
      bulletinRecordClasses.some(bulletinClass => monitoredClass === bulletinClass)
    );
    
    logger.log(`üè∑Ô∏è Nice sƒ±nƒ±f kesi≈üimi: ${hasOverlap ? 'VAR' : 'YOK'}`);
    
    // Debug: hangi sƒ±nƒ±flar e≈üle≈üti?
    if (hasOverlap) {
      const matchingClasses = monitoredClasses.filter(monitoredClass => 
        bulletinRecordClasses.some(bulletinClass => monitoredClass === bulletinClass)
      );
      logger.log(`‚úÖ E≈üle≈üen sƒ±nƒ±flar: ${matchingClasses.join(', ')}`);
    }
    
    return hasOverlap;
    
  } catch (error) {
    logger.error('‚ùå Nice class kar≈üƒ±la≈ütƒ±rma hatasƒ±:', error);
    return false;
  }
}

// ======== Ana Benzerlik Skorlama Fonksiyonu (scorer.js'ten kopyalandƒ±) ========
function levenshteinDistance(a, b) {
  const matrix = [];

  const lenA = a.length;
  const lenB = b.length;

  for (let i = 0; i <= lenB; i++) matrix[i] = [i];
  for (let j = 0; j <= lenA; j++) matrix[0][j] = j;

  for (let i = 1; i <= lenB; i++) {
    for (let j = 1; j <= lenA; j++) {
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1, // substitution
          matrix[i][j - 1] + 1,     // insertion
          matrix[i - 1][j] + 1      // deletion
        );
      }
    }
  }
  return matrix[lenB][lenA];
}

function levenshteinSimilarity(a, b) {
  if (!a || !b) return 0;
  const distance = levenshteinDistance(a, b);
  const maxLen = Math.max(a.length, b.length);
  return maxLen === 0 ? 1 : (1 - distance / maxLen);
}

function calculateSimilarityScoreInternal(hitMarkName, searchMarkName, hitApplicationDate, searchApplicationDate, hitNiceClasses, searchNiceClasses) {
    // Jenerik ibare temizliƒüi
    const isSearchMultiWord = searchMarkName.trim().split(/\s+/).length > 1;
    const isHitMultiWord = (hitMarkName || '').trim().split(/\s+/).length > 1;

    const cleanedSearchName = cleanMarkName(searchMarkName || '', isSearchMultiWord).toLowerCase().trim();
    const cleanedHitName = cleanMarkName(hitMarkName || '', isHitMultiWord).toLowerCase().trim();

    logger.log(`üìä Skorlama: '${searchMarkName}' (temizlenmi≈ü: '${cleanedSearchName}') vs '${hitMarkName}' (temizlenmi≈ü: '${cleanedHitName}')`);

    if (!cleanedSearchName || !cleanedHitName) {
        return { finalScore: 0.0, positionalExactMatchScore: 0.0 }; // Her iki skoru da d√∂nd√ºr
    }

    // Tam e≈üle≈üme kontrol√º (en y√ºksek √∂ncelik)
    if (cleanedSearchName === cleanedHitName) {
        return { finalScore: 1.0, positionalExactMatchScore: 1.0 }; // Her iki skoru da d√∂nd√ºr
    }

    // ======== Alt Benzerlik Skorlarƒ± ========
    const levenshteinScore = (() => {
        const matrix = [];
        if (cleanedSearchName.length === 0) return cleanedHitName.length === 0 ? 1.0 : 0.0;
        if (cleanedHitName.length === 0) return cleanedSearchName.length === 0 ? 1.0 : 0.0;
    
        for (let i = 0; i <= cleanedHitName.length; i++) {
            matrix[i] = [i];
        }
        for (let j = 0; j <= cleanedSearchName.length; j++) {
            matrix[0][j] = j;
        }
    
        for (let i = 1; i <= cleanedHitName.length; i++) {
            for (let j = 1; j <= cleanedSearchName.length; j++) {
                const cost = cleanedHitName.charAt(i - 1) === cleanedSearchName.charAt(j - 1) ? 0 : 1;
                matrix[i][j] = Math.min(
                    matrix[i - 1][j - 1] + cost, // substitution
                    matrix[i][j - 1] + 1,     // insertion
                    matrix[i - 1][j] + 1      // deletion
                );
            }
        }
        const maxLength = Math.max(cleanedSearchName.length, cleanedHitName.length);
        return maxLength === 0 ? 1.0 : 1.0 - (matrix[cleanedHitName.length][cleanedSearchName.length] / maxLength);
    })();
    logger.log(`   - Levenshtein Score: ${levenshteinScore.toFixed(2)}`);

    const jaroWinklerScore = (() => {
        const s1 = cleanedSearchName;
        const s2 = cleanedHitName;
        if (s1 === s2) return 1.0;

        let m = 0;
        const s1_len = s1.length;
        const s2_len = s2.length;

        const range = Math.floor(Math.max(s1_len, s2_len) / 2) - 1;
        const s1_matches = new Array(s1_len);
        const s2_matches = new Array(s2_len);

        for (let i = 0; i < s1_len; i++) {
            const char_s1 = s1[i];
            for (let j = Math.max(0, i - range); j < Math.min(s2_len, i + range + 1); j++) {
                if (char_s1 === s2[j] && !s2_matches[j]) {
                    s1_matches[i] = true;
                    s2_matches[j] = true;
                    m++;
                    break;
                }
            }
        }

        if (m === 0) return 0.0;

        let k = 0;
        let t = 0;
        for (let i = 0; i < s1_len; i++) {
            if (s1_matches[i]) {
                let j;
                for (j = k; j < s2_len; j++) {
                    if (s2_matches[j]) {
                        k = j + 1;
                        break;
                    }
                }
                if (s1[i] !== s2[j]) {
                    t++;
                }
            }
        }
        t = t / 2;

        const jaro_score = (m / s1_len + m / s2_len + (m - t) / m) / 3;

        const p = 0.1;
        let l = 0;
        const max_prefix_len = 4;

        for (let i = 0; i < Math.min(s1_len, s2_len, max_prefix_len); i++) {
            if (s1[i] === s2[i]) {
                l++;
            } else {
                break;
            }
        }

        return jaro_score + l * p * (1 - jaro_score);
    })();
    logger.log(`   - Jaro-Winkler Score: ${jaroWinklerScore.toFixed(2)}`);

    const ngramScore = (() => {
        const s1 = cleanedSearchName;
        const s2 = cleanedHitName;
        const n = 2;
        if (!s1 || !s2) return 0.0;
        if (s1 === s2) return 1.0;

        const getNGrams = (s, num) => {
            const ngrams = new Set();
            for (let i = 0; i <= s.length - num; i++) {
                ngrams.add(s.substring(i, i + num));
            }
            return ngrams;
        };

        const ngrams1 = getNGrams(s1, n);
        const ngrams2 = getNGrams(s2, n);

        if (ngrams1.size === 0 && ngrams2.size === 0) return 1.0;
        if (ngrams1.size === 0 || ngrams2.size === 0) return 0.0;

        let common = 0;
        ngrams1.forEach(ngram => {
            if (ngrams2.has(ngram)) {
                common++;
            }
        });

        return common / Math.min(ngrams1.size, ngrams2.size);
    })();
    logger.log(`   - N-gram Score (n=2): ${ngramScore.toFixed(2)}`);

    const visualScore = (() => {
        const visualPenalty = visualMismatchPenalty(cleanedSearchName, cleanedHitName);
        const maxPossibleVisualPenalty = Math.max(cleanedSearchName.length, cleanedHitName.length) * 1.0;
        return maxPossibleVisualPenalty === 0 ? 1.0 : (1.0 - (visualPenalty / maxPossibleVisualPenalty));
    })();
    logger.log(`   - Visual Score: ${visualScore.toFixed(2)}`);

    const prefixScore = (() => {
        const s1 = cleanedSearchName;
        const s2 = cleanedHitName;
        const length = 3;
        if (!s1 || !s2) return 0.0;
        const prefix1 = s1.substring(0, Math.min(s1.length, length));
        const prefix2 = s2.substring(0, Math.min(s2.length, length));

        if (prefix1 === prefix2) return 1.0;
        if (prefix1.length === 0 && prefix2.length === 0) return 1.0;

        return levenshteinSimilarity(prefix1, prefix2); // √ñnek kar≈üƒ±la≈ütƒ±rmasƒ± i√ßin levenshteinSimilarity kullan
    })();
    logger.log(`   - Prefix Score (len 3): ${prefixScore.toFixed(2)}`);

    // 6. Kelime Bazƒ±nda En Y√ºksek Benzerlik Skoru + E≈üle≈üen Kelime √áifti
    const { maxWordScore, maxWordPair } = (() => {
        const s1 = cleanedSearchName;
        const s2 = cleanedHitName;
        if (!s1 || !s2) return { maxWordScore: 0.0, maxWordPair: null };

        const words1 = s1.split(' ').filter(w => w.length > 0);
        const words2 = s2.split(' ').filter(w => w.length > 0);

        if (words1.length === 0 && words2.length === 0) return { maxWordScore: 1.0, maxWordPair: null };
        if (words1.length === 0 || words2.length === 0) return { maxWordScore: 0.0, maxWordPair: null };

        let maxSim = 0.0;
        let pair = null;
        for (const w1 of words1) {
            for (const w2 of words2) {
                const sim = levenshteinSimilarity(w1, w2);
                if (sim > maxSim) {
                    maxSim = sim;
                    pair = [w1, w2];
                }
            }
        }
        return { maxWordScore: maxSim, maxWordPair: pair };
    })();

    logger.log(`   - Max Word Score: ${maxWordScore.toFixed(2)}`);

    // Yeni: Konumsal Tam E≈üle≈üme Skoru (√∂rn: ilk 3 karakter tam e≈üle≈üiyorsa)
    const positionalExactMatchScore = (() => {
        const s1 = cleanedSearchName;
        const s2 = cleanedHitName;
        if (!s1 || !s2) return 0.0;

        // ƒ∞lk 3 karakteri b√ºy√ºk/k√º√ß√ºk harf duyarsƒ±z kar≈üƒ±la≈ütƒ±r
        const len = Math.min(s1.length, s2.length, 3);
        if (len === 0) return 0.0; // Kar≈üƒ±la≈ütƒ±rƒ±lacak karakter yok

        // T√ºm karakterleri kontrol et - HEPSƒ∞ e≈üle≈ümeli
        for (let i = 0; i < len; i++) {
            if (s1[i] !== s2[i]) {  // ‚úÖ D√úZELTME: Farklƒ± karakter bulduƒüunda
                return 0.0;          // ‚úÖ D√úZELTME: 0.0 d√∂nd√ºr ve √ßƒ±k
            }
        }
        return 1.0; // ‚úÖ D√úZELTME: Sadece T√úM karakterler e≈üle≈üirse 1.0 d√∂nd√ºr
    })();
    logger.log(`   - Positional Exact Match Score (first 3 chars): ${positionalExactMatchScore.toFixed(2)}`);

    // ======== YENƒ∞ KURAL: Y√ºksek Kelime Benzerliƒüi Kontrol√º ve √ñnceliklendirme ========

    const HIGH_WORD_SIMILARITY_THRESHOLD = 0.70;

    // E≈üle≈üen en iyi kelime √ßifti tam e≈üle≈ümeyse uzunluƒüunu kontrol et
    const exactWordLen =
        (maxWordPair && maxWordPair[0] === maxWordPair[1]) ? maxWordPair[0].length : 0;

    if (maxWordScore >= HIGH_WORD_SIMILARITY_THRESHOLD) {
        // Eƒüer tam kelime e≈üle≈ümesi ile 1.0 elde edildiyse ve bu kelime 2 karakterden kƒ±saysa
        // erken d√∂n√º≈ü√º engelle (tek harfli "a" gibi durumlar %100 yapmasƒ±n)
        if (maxWordScore === 1.0 && exactWordLen < 2) {
            logger.log(`   *** Tam kelime e≈üle≈ümesi tek/√ßok kƒ±sa kelime ile (len=${exactWordLen}) bulundu; erken d√∂n√º≈ü iptal edildi. ***`);
            // Erken d√∂nme, alttaki karma skorlamaya devam
        } else {
            logger.log(`   *** Y√ºksek kelime bazƒ±nda benzerlik tespit edildi (maxWordScore=${(maxWordScore*100).toFixed(0)}%). Erken d√∂n√º≈ü uygulanƒ±yor. ***`);
            return { finalScore: maxWordScore, positionalExactMatchScore: positionalExactMatchScore };
        }
    }
    
    // ======== ƒ∞sim Benzerliƒüi Alt Toplamƒ± Hesaplama (%95 Aƒüƒ±rlƒ±k) ========
    const nameSimilarityRaw = (
        levenshteinScore * 0.30 +
        jaroWinklerScore * 0.25 +
        ngramScore * 0.15 +
        visualScore * 0.15 +
        prefixScore * 0.10 +
        maxWordScore * 0.05
    );

    const nameSimilarityWeighted = nameSimilarityRaw * 0.95;
    logger.log(`   - Name Similarity (weighted 95%): ${nameSimilarityWeighted.toFixed(2)}`);

    // ======== Fonetik Benzerlik Skoru (%5 Aƒüƒ±rlƒ±k) ========
    const phoneticScoreRaw = isPhoneticallySimilar(searchMarkName, hitMarkName);
    const phoneticSimilarityWeighted = phoneticScoreRaw * 0.05;
    logger.log(`   - Phonetic Score (weighted 5%): ${phoneticSimilarityWeighted.toFixed(2)}`);

    // ======== Genel Benzerlik Skoru ========
    let finalScore = nameSimilarityWeighted + phoneticSimilarityWeighted;

    finalScore = Math.max(0.0, Math.min(1.0, finalScore));

    logger.log(`   - FINAL SCORE: ${finalScore.toFixed(2)}\n`);
    return { finalScore: finalScore, positionalExactMatchScore: positionalExactMatchScore }; // Her iki skoru da d√∂nd√ºr
}

// ======== Yeni Cloud Function: Sunucu Tarafƒ±nda Marka Benzerliƒüi Aramasƒ± ========
// functions/index.js - performTrademarkSimilaritySearch fonksiyonunun d√ºzeltilmi≈ü kƒ±smƒ±

// functions/index.js (sadece performTrademarkSimilaritySearch fonksiyonu g√ºncellenmi≈ütir)

export const performTrademarkSimilaritySearch = onCall(
  {
    region: 'europe-west1',
    timeoutSeconds: 300,
    memory: '1GiB'
  },
  async (request) => {
    const { monitoredMarks, selectedBulletinId } = request.data;

    if (!Array.isArray(monitoredMarks) || monitoredMarks.length === 0 || !selectedBulletinId) {
      throw new HttpsError(
        'invalid-argument',
        'Missing required parameters: monitoredMarks (array) or selectedBulletinId'
      );
    }

    logger.log('üöÄ Cloud Function: performTrademarkSimilaritySearch BA≈ûLATILDI', {
      numMonitoredMarks: monitoredMarks.length,
      selectedBulletinId,
      monitoredMarksDetails: monitoredMarks.map(m => ({ id: m.id, markName: m.markName }))
    });

    try {
      let bulletinRecordsSnapshot;

      // √ñnce bulletinId olarak direkt ara
      bulletinRecordsSnapshot = await adminDb.collection('trademarkBulletinRecords')
        .where('bulletinId', '==', selectedBulletinId)
        .get();

      // Eƒüer sonu√ß yoksa veya g√∂nderilen deƒüer "469_27052025" gibi ise ‚Üí bulletinNo ile ara
      if (!bulletinRecordsSnapshot || bulletinRecordsSnapshot.empty) {
        // "_" i√ßeriyorsa sadece ilk kƒ±smƒ± al
        let selectedBulletinNo = selectedBulletinId;
        if (selectedBulletinId.includes('_')) {
          selectedBulletinNo = selectedBulletinId.split('_')[0];
        }

        const bulletinDoc = await adminDb.collection('trademarkBulletins')
          .where('bulletinNo', '==', selectedBulletinNo)
          .limit(1)
          .get();

        if (!bulletinDoc.empty) {
          const bulletinIdFromNo = bulletinDoc.docs[0].id;
          bulletinRecordsSnapshot = await adminDb.collection('trademarkBulletinRecords')
            .where('bulletinId', '==', bulletinIdFromNo)
            .get();
        }
      }

      const bulletinRecords = bulletinRecordsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      logger.log(`‚úÖ ${bulletinRecords.length} kayƒ±t bulundu.`);

      const allResults = [];

      for (const monitoredMark of monitoredMarks) {
        logger.log("üîç ƒ∞≈ülenen monitored mark:", {
          id: monitoredMark.id,
          markName: monitoredMark.markName,
          applicationDate: monitoredMark.applicationDate,
          niceClasses: monitoredMark.niceClasses
        });

        const markNameRaw = monitoredMark.markName || monitoredMark.title || '';
        const markName = (typeof markNameRaw === 'string') ? markNameRaw.trim() : '';
        const applicationDate = monitoredMark.applicationDate || null;
        const niceClasses = monitoredMark.niceClasses || [];

        if (!markName) {
          logger.warn(`‚ö†Ô∏è ƒ∞zlenen markanƒ±n adƒ± eksik:`, monitoredMark);
          continue;
        }

        // Aranan markanƒ±n temizlenmi≈ü hali (burada tanƒ±mlanmasƒ± gerekiyor)
        const cleanedSearchName = cleanMarkName(markName, markName.trim().split(/\s+/).length > 1); // cleanMarkName fonksiyonuna eri≈üilebilir olmalƒ±

        logger.log(`üîé Arama: '${markName}' (ID: ${monitoredMark.id})`);

        let matchCount = 0;

        for (const hit of bulletinRecords) {
          // Tarih filtresi
          if (!isValidBasedOnDate(hit.applicationDate, applicationDate)) {
            continue;
          }

          // Nice sƒ±nƒ±f filtresi - AKTIF
          const hasNiceClassOverlap = hasOverlappingNiceClasses(monitoredMark, hit.niceClasses);

          // Eƒüer Nice sƒ±nƒ±f kesi≈üimi yoksa atla
          // NOTE: Previously skipped when no Nice class overlap.
// if (!hasNiceClassOverlap) { continue; }

          // Benzerlik skoru
          const { finalScore: similarityScore, positionalExactMatchScore } = calculateSimilarityScoreInternal(
            hit.markName,
            markName,
            hit.applicationDate,
            applicationDate,
            hit.niceClasses,
            niceClasses
          );

          const SIMILARITY_THRESHOLD = 0.5; //

          // Yeni Kriter Kontrol√º: Aranan marka, bulunan markanƒ±n ba≈üƒ±nda veya sonunda tam ge√ßiyor mu?
        const cleanedHitName = cleanMarkName(hit.markName, (hit.markName || '').trim().split(/\s+/).length > 1);
        let isPrefixSuffixExactMatch = false;

        // Minimum uzunluk kontrol√º eklendi, √ßok kƒ±sa kelimelerin e≈üle≈ümesi anlamsƒ±z olabilir.
        const MIN_SEARCH_LENGTH = 3; // En az 3 karakterlik bir e≈üle≈üme arƒ±yoruz

        if (cleanedSearchName.length >= MIN_SEARCH_LENGTH) {
            // Aranan markanƒ±n t√ºm kelimelerini kontrol et
            const searchWords = cleanedSearchName.split(' ').filter(word => word.length >= MIN_SEARCH_LENGTH);
            
            for (const searchWord of searchWords) {
                // Bulunan markanƒ±n temizlenmi≈ü halinde aranan kelime ge√ßiyor mu?
                if (cleanedHitName.includes(searchWord)) {
                    isPrefixSuffixExactMatch = true;
                    logger.log(`üéØ Tam e≈üle≈üme bulundu: '${searchWord}' kelimesi '${cleanedHitName}' i√ßinde ge√ßiyor`);
                    break; // Bir e≈üle≈üme bulmak yeterli
                }
            }
            
            // Alternatif olarak: Aranan markanƒ±n tamamƒ± bulunan markada ge√ßiyor mu?
            // (kelime kelime deƒüil, b√ºt√ºn olarak)
            if (!isPrefixSuffixExactMatch && cleanedHitName.includes(cleanedSearchName)) {
                isPrefixSuffixExactMatch = true;
                logger.log(`üéØ Tam e≈üle≈üme bulundu: '${cleanedSearchName}' tamamƒ± '${cleanedHitName}' i√ßinde ge√ßiyor`);
            }
        }
          // G√úNCELLENMƒ∞≈û Fƒ∞LTRELEME KO≈ûULU

          if (
              similarityScore < SIMILARITY_THRESHOLD && 
              positionalExactMatchScore < SIMILARITY_THRESHOLD && 
              !isPrefixSuffixExactMatch
          ) {
            // Hi√ßbir ge√ßerli kriteri saƒülamadƒ±, bu y√ºzden atla
            logger.log(`‚è© Atlandƒ±: Final Skor: ${similarityScore.toFixed(2)}, Positional: ${positionalExactMatchScore.toFixed(2)}, Prefix/Suffix E≈üle≈üme Yok - ${hit.markName}`);
            continue;
          }

          // Bu noktaya ula≈üan t√ºm kayƒ±tlar, yukarƒ±daki √º√ß 'continue' ko≈üulundan en az birini kar≈üƒ±lamadƒ±ƒüƒ± i√ßin eklenir.
          // Yani, ya similarityScore >= THRESHOLD, ya positionalExactMatchScore >= THRESHOLD, ya da isPrefixSuffixExactMatch === true.
          matchCount++;

          // *** √ñNEMLƒ∞: T√ºm gerekli alanlarƒ± ekle ***
          
// Compute 'isEarlier' (hit earlier than monitored application date)
let isEarlier = false;
try {
  const searchDate = applicationDate ? new Date(applicationDate) : null;
  const hitDate = hit.applicationDate ? new Date(hit.applicationDate) : null;
  if (searchDate && hitDate) {
    isEarlier = hitDate.getTime() < searchDate.getTime();
  }
} catch (e) {
  isEarlier = false;
}
allResults.push({
            objectID: hit.id,
            markName: hit.markName,
            applicationNo: hit.applicationNo,
            applicationDate: hit.applicationDate,
            niceClasses: hit.niceClasses,
            holders: hit.holders,
            imagePath: hit.imagePath,
            bulletinId: hit.bulletinId,
            similarityScore,
            positionalExactMatchScore,
            sameClass: hasNiceClassOverlap, // ≈ûu anda true olarak ayarlƒ±
            
            // *** FRONTEND ƒ∞√áƒ∞N GEREKLƒ∞ ALANLAR ***
            monitoredTrademark: markName, // Frontend'in e≈üle≈ütirme i√ßin kullandƒ±ƒüƒ± alan
            monitoredNiceClasses: monitoredMark.niceClassSearch || [],
            monitoredTrademarkId: monitoredMark.id, // Eski uyumluluk i√ßin
            isEarlier: isEarlier
});
        }

        logger.log(`üìä '${markName}' (ID: ${monitoredMark.id}) i√ßin ${matchCount} e≈üle≈üme bulundu`);
      }

      allResults.sort((a, b) => b.similarityScore - a.similarityScore);
      
      // *** SON KONTROL LOGU ***
      logger.log(`‚úÖ Toplam ${allResults.length} sonu√ß d√∂nd√ºr√ºl√ºyor`, {
        sampleResult: allResults[0] ? {
          markName: allResults[0].markName,
          monitoredTrademark: allResults[0].monitoredTrademark,
          monitoredMarkId: allResults[0].monitoredMarkId,
          monitoredTrademarkId: allResults[0].monitoredTrademarkId
        } : 'No results'
      });

      return { success: true, results: allResults };
    } catch (error) {
      logger.error('‚ùå Cloud Function hata:', error);
      throw new HttpsError('internal', 'Marka benzerliƒüi aramasƒ± sƒ±rasƒ±nda hata olu≈ütu.', error.message);
    }
  }
);
const bucket = admin.storage().bucket();
export const generateSimilarityReport = onCall(
  {
    timeoutSeconds: 540,
    memory: "1GiB",
    region: "europe-west1"
  },
  async (request) => {
    try {
      const { results } = request.data;
      if (!results || !Array.isArray(results)) {
        throw new Error("Ge√ßersiz veri formatƒ±");
      }

      // --- Sahip bazƒ±nda grupla ---
      const owners = {};
      results.forEach((m) => {
        const owner = (m.monitoredMark && m.monitoredMark.ownerName) || "Bilinmeyen Sahip";
        if (!owners[owner]) owners[owner] = [];
        owners[owner].push(m);
      });

      const archive = archiver("zip", { zlib: { level: 9 } });
      const passthrough = new stream.PassThrough();
      archive.pipe(passthrough);

      // Her sahip i√ßin ayrƒ± dosya olu≈ütur
      for (const [ownerName, matches] of Object.entries(owners)) {
        const doc = await createProfessionalReport(ownerName, matches);
        const buffer = await Packer.toBuffer(doc);
        archive.append(buffer, { name: `${sanitizeFileName(ownerName)}_Benzerlik_Raporu.docx` });
      }

      await archive.finalize();
      const chunks = [];
      for await (const chunk of passthrough) chunks.push(chunk);
      const finalBuffer = Buffer.concat(chunks);

      return {
        success: true,
        file: finalBuffer.toString("base64")
      };
    } catch (error) {
      console.error("Rapor olu≈üturma hatasƒ±:", error);
      return { success: false, error: error.message };
    }
  }
);

// Ana rapor olu≈üturma fonksiyonu
async function createProfessionalReport(ownerName, matches) {
  // --- Benzer marka bazƒ±nda grupla ---
  const grouped = {};
  matches.forEach((m) => {
    const key = (m.similarMark && m.similarMark.applicationNo) || 'unknown';
    if (!grouped[key]) {
      grouped[key] = { 
        similarMark: m.similarMark || {}, 
        monitoredMarks: [] 
      };
    }
    grouped[key].monitoredMarks.push(m.monitoredMark || {});
  });

  const reportContent = [];

  // === RAPOR BA≈ûLIƒûI ===
  reportContent.push(...createReportHeader(ownerName, matches.length));
  
  // === √ñZ Bƒ∞LGƒ∞LER ===
  reportContent.push(...createExecutiveSummary(grouped));
  
  // === SAYFA KESME ===
  reportContent.push(new Paragraph({ 
    children: [new PageBreak()]
  }));

  // === DETAY ANALƒ∞Z ===
  for (const [index, group] of Object.entries(grouped).entries()) {
    if (index > 0) {
      reportContent.push(new Paragraph({ 
        children: [new PageBreak()]
      }));
    }
    
    const [_, g] = group;
    reportContent.push(...createDetailedAnalysisSection(g, index + 1));
  }

  // === SONU√á VE √ñNERƒ∞LER ===
  reportContent.push(new Paragraph({ 
    children: [new PageBreak()]
  }));
  reportContent.push(...createConclusionSection(grouped));

  return new Document({
    creator: "IP Manager",
    description: `${ownerName} Marka Benzerlik Raporu`,
    title: `Marka Benzerlik Raporu`,
    sections: [{
      properties: {},
      children: reportContent
    }]
  });
}

// === RAPOR BA≈ûLIƒûI ===
function createReportHeader(ownerName, totalMatches) {
  const currentDate = new Date().toLocaleDateString('tr-TR', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });

  return [
    // Ana ba≈ülƒ±k
    new Paragraph({
      children: [
        new TextRun({
          text: "MARKA BENZERLƒ∞K ANALƒ∞Zƒ∞ RAPORU",
          bold: true,
          size: 32,
          color: "2E4BC7"
        })
      ],
      alignment: AlignmentType.CENTER,
      spacing: { after: 400 }
    }),

    // Alt ba≈ülƒ±k
    new Paragraph({
      children: [
        new TextRun({
          text: `${ownerName} ƒ∞√ßin Detaylƒ± ƒ∞nceleme`,
          bold: true,
          size: 24,
          color: "666666"
        })
      ],
      alignment: AlignmentType.CENTER,
      spacing: { after: 600 }
    }),

    // Rapor bilgileri tablosu
    new Table({
      width: { size: 100, type: WidthType.PERCENTAGE },
      rows: [
        new TableRow({
          children: [
            createInfoCell("Rapor Tarihi:", currentDate),
            createInfoCell("Toplam Tespit:", `${totalMatches} adet benzer marka`)
          ]
        }),
        new TableRow({
          children: [
            createInfoCell("Analiz Kapsamƒ±:", "Marka benzerlik tespiti"),
            createInfoCell("Rapor Durumu:", "Tamamlandƒ±")
          ]
        })
      ]
    }),

    new Paragraph({ text: "", spacing: { after: 600 } })
  ];
}

// === √ñZ Bƒ∞LGƒ∞LER B√ñL√úM√ú ===
function createExecutiveSummary(grouped) {
  const totalSimilarMarks = Object.keys(grouped).length;
  const totalMonitoredMarks = Object.values(grouped).reduce((sum, g) => sum + g.monitoredMarks.length, 0);
  
  // Risk seviyesi analizi
  let highRisk = 0, mediumRisk = 0, lowRisk = 0;
  Object.values(grouped).forEach(g => {
    const similarity = parseFloat(g.similarMark.similarity) || 0;
    if (similarity >= 70) highRisk++;
    else if (similarity >= 50) mediumRisk++;
    else lowRisk++;
  });

  return [
    new Paragraph({
      children: [
        new TextRun({
          text: "Y√ñNETƒ∞Cƒ∞ √ñZETƒ∞",
          bold: true,
          size: 20,
          color: "2E4BC7"
        })
      ],
      heading: HeadingLevel.HEADING_1,
      spacing: { before: 400, after: 300 }
    }),

    new Paragraph({
      children: [
        new TextRun({
          text: "Bu rapor, izlenen markalarƒ±nƒ±za y√∂nelik benzerlik analizi sonu√ßlarƒ±nƒ± i√ßermektedir. ",
          size: 22
        }),
        new TextRun({
          text: "A≈üaƒüƒ±daki √∂nemli bulgular tespit edilmi≈ütir:",
          size: 22,
          bold: true
        })
      ],
      spacing: { after: 300 }
    }),

    // √ñzet istatistikler tablosu
    new Table({
      width: { size: 100, type: WidthType.PERCENTAGE },
      rows: [
        new TableRow({
          children: [
            createSummaryHeaderCell("Analiz Konusu"),
            createSummaryHeaderCell("Sonu√ß"),
            createSummaryHeaderCell("Deƒüerlendirme")
          ]
        }),
        new TableRow({
          children: [
            createSummaryCell("Benzer Marka Sayƒ±sƒ±"),
            createSummaryCell(`${totalSimilarMarks} adet`),
            createSummaryCell(totalSimilarMarks > 5 ? "Y√ºksek" : totalSimilarMarks > 2 ? "Orta" : "D√º≈ü√ºk")
          ]
        }),
        new TableRow({
          children: [
            createSummaryCell("ƒ∞zlenen Marka Sayƒ±sƒ±"),
            createSummaryCell(`${totalMonitoredMarks} adet`),
            createSummaryCell("Aktif ƒ∞zleme")
          ]
        }),
        new TableRow({
          children: [
            createSummaryCell("Y√ºksek Risk (‚â•%70)"),
            createSummaryCell(`${highRisk} adet`),
            createSummaryCell(highRisk > 0 ? "Acil ƒ∞nceleme Gerekli" : "Risk Yok")
          ]
        }),
        new TableRow({
          children: [
            createSummaryCell("Orta Risk (%50-69)"),
            createSummaryCell(`${mediumRisk} adet`),
            createSummaryCell(mediumRisk > 0 ? "ƒ∞zleme Gerekli" : "Risk Yok")
          ]
        }),
        new TableRow({
          children: [
            createSummaryCell("D√º≈ü√ºk Risk (<50%)"),
            createSummaryCell(`${lowRisk} adet`),
            createSummaryCell("D√º≈ü√ºk √ñncelik")
          ]
        })
      ]
    })
  ];
}

// === DETAYLI ANALƒ∞Z B√ñL√úM√ú ===
function createDetailedAnalysisSection(group, sectionIndex) {
  const elements = [];
  const similarMark = group.similarMark;
  const similarity = parseFloat(similarMark.similarity) || 0;
  
  // Risk seviyesi belirleme
  let riskLevel = "D√ú≈û√úK";
  let riskColor = "28A745";
  if (similarity >= 70) {
    riskLevel = "Y√úKSEK";
    riskColor = "DC3545";
  } else if (similarity >= 50) {
    riskLevel = "ORTA";
    riskColor = "FFC107";
  }

  // B√∂l√ºm ba≈ülƒ±ƒüƒ±
  elements.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `${sectionIndex}. BENZER MARKA ANALƒ∞Zƒ∞`,
          bold: true,
          size: 18,
          color: "2E4BC7"
        })
      ],
      heading: HeadingLevel.HEADING_1,
      spacing: { before: 400, after: 300 }
    })
  );

  // Benzer marka bilgi kartƒ±
  elements.push(
    new Table({
      width: { size: 100, type: WidthType.PERCENTAGE },
      rows: [
        new TableRow({
          children: [
            new TableCell({
              children: [
                new Paragraph({
                  children: [
                    new TextRun({
                      text: "üéØ BENZER MARKA Bƒ∞LGƒ∞LERƒ∞",
                      bold: true,
                      size: 32,
                      color: "FFFFFF"
                    })
                  ],
                  alignment: AlignmentType.CENTER
                })
              ],
              columnSpan: 2,
              shading: { fill: "2E4BC7", type: "clear", color: "auto" }
            })
          ]
        }),
        new TableRow({
          children: [
            createDetailCell("Marka Adƒ±:", similarMark.name || "-"),
            createDetailCell("Ba≈üvuru No:", similarMark.applicationNo || "-")
          ]
        }),
        new TableRow({
          children: [
            createDetailCell("Ba≈üvuru Tarihi:", similarMark.date || "-"),
            createDetailCell("Nice Sƒ±nƒ±flarƒ±:", Array.isArray(similarMark.niceClass) ? 
              similarMark.niceClass.join(", ") : (similarMark.niceClass || "-"))
          ]
        }),
        new TableRow({
          children: [
            new TableCell({
              children: [
                new Paragraph({
                  children: [
                    new TextRun({
                      text: "Benzerlik Oranƒ±: ",
                      bold: true
                    }),
                    new TextRun({
                      text: `%${similarity.toFixed(1)}`,
                      bold: true,
                      color: riskColor,
                      size: 24
                    })
                  ]
                })
              ]
            }),
            new TableCell({
              children: [
                new Paragraph({
                  children: [
                    new TextRun({
                      text: "Risk Seviyesi: ",
                      bold: true
                    }),
                    new TextRun({
                      text: riskLevel,
                      bold: true,
                      color: riskColor,
                      size: 24
                    })
                  ]
                })
              ]
            })
          ]
        })
      ]
    })
  );

  elements.push(new Paragraph({ text: "", spacing: { after: 300 } }));

  // ƒ∞zlenen markalar tablosu
  elements.push(
    new Paragraph({
      children: [
        new TextRun({
          text: "üîç ƒ∞ZLENEN MARKALAR",
          bold: true,
          size: 16,
          color: "2E4BC7"
        })
      ],
      spacing: { before: 300, after: 200 }
    })
  );

  const monitoredTableRows = [
    new TableRow({
      children: [
        createTableHeaderCell("Marka Adƒ±"),
        createTableHeaderCell("Ba≈üvuru No"),
        createTableHeaderCell("Ba≈üvuru Tarihi"),
        createTableHeaderCell("Nice Sƒ±nƒ±flarƒ±"),
        createTableHeaderCell("Durum")
      ]
    })
  ];

  group.monitoredMarks.forEach(mark => {
    monitoredTableRows.push(
      new TableRow({
        children: [
          createTableDataCell(mark.markName || mark.name || "-"),
          createTableDataCell(mark.applicationNo || "-"),
          createTableDataCell(mark.date || mark.applicationDate || "-"),
          createTableDataCell(Array.isArray(mark.niceClass) ? 
            mark.niceClass.join(", ") : (mark.niceClass || mark.niceClasses || "-")),
          createTableDataCell("Aktif ƒ∞zleme")
        ]
      })
    );
  });

  elements.push(
    new Table({
      width: { size: 100, type: WidthType.PERCENTAGE },
      rows: monitoredTableRows
    })
  );

  // Not alanƒ± varsa ekle
  if (similarMark.note && similarMark.note.trim()) {
    elements.push(
      new Paragraph({ text: "", spacing: { after: 300 } }),
      new Paragraph({
        children: [
          new TextRun({
            text: "üìù NOTLAR",
            bold: true,
            size: 14,
            color: "2E4BC7"
          })
        ],
        spacing: { after: 200 }
      }),
      new Paragraph({
        children: [
          new TextRun({
            text: similarMark.note,
            italics: true,
            size: 22
          })
        ],
        spacing: { before: 100, after: 300 }
      })
    );
  }

  return elements;
}

// === SONU√á VE √ñNERƒ∞LER ===
function createConclusionSection(grouped) {
  const totalMarks = Object.keys(grouped).length;
  const highRiskMarks = Object.values(grouped).filter(g => 
    parseFloat(g.similarMark.similarity) >= 70).length;

  return [
    new Paragraph({
      children: [
        new TextRun({
          text: "SONU√á VE √ñNERƒ∞LER",
          bold: true,
          size: 20,
          color: "2E4BC7"
        })
      ],
      heading: HeadingLevel.HEADING_1,
      spacing: { before: 400, after: 300 }
    }),

    new Paragraph({
      children: [
        new TextRun({
          text: `Bu analiz kapsamƒ±nda toplam ${totalMarks} adet benzer marka tespit edilmi≈ütir. `,
          size: 22
        }),
        new TextRun({
          text: `Bunlardan ${highRiskMarks} adedi y√ºksek risk kategorisindedir.`,
          size: 22,
          bold: true,
          color: highRiskMarks > 0 ? "DC3545" : "28A745"
        })
      ],
      spacing: { after: 300 }
    }),

    new Paragraph({
      children: [
        new TextRun({
          text: "üìã √ñNERƒ∞LER:",
          bold: true,
          size: 16,
          color: "2E4BC7"
        })
      ],
      spacing: { before: 300, after: 200 }
    }),

    ...(highRiskMarks > 0 ? [
      new Paragraph({
        children: [
          new TextRun({ text: "üî¥ ", size: 20 }),
          new TextRun({
            text: "Y√ºksek riskli markalar i√ßin acil hukuki inceleme yapƒ±lmasƒ± √∂nerilir.",
            size: 22,
            bold: true
          })
        ],
        spacing: { after: 150 }
      })
    ] : []),

    new Paragraph({
      children: [
        new TextRun({ text: "üìä ", size: 20 }),
        new TextRun({
          text: "Nice sƒ±nƒ±f √ßakƒ±≈ümalarƒ±nƒ±n detaylƒ± analiz edilmesi",
          size: 22
        })
      ],
      spacing: { after: 150 }
    }),

    new Paragraph({
      children: [
        new TextRun({ text: "‚öñÔ∏è ", size: 20 }),
        new TextRun({
          text: "Gerekli durumlarda itiraz prosed√ºrlerinin ba≈ülatƒ±lmasƒ±",
          size: 22
        })
      ],
      spacing: { after: 150 }
    }),

    new Paragraph({
      children: [
        new TextRun({ text: "üîç ", size: 20 }),
        new TextRun({
          text: "D√ºzenli izleme s√ºrecinin devam ettirilmesi",
          size: 22
        })
      ],
      spacing: { after: 400 }
    }),

    // Rapor footer
    new Paragraph({
      children: [
        new TextRun({
          text: "Bu rapor IP Manager - Marka Analiz Sistemi tarafƒ±ndan otomatik olarak olu≈üturulmu≈ütur.",
          size: 18,
          italics: true,
          color: "666666"
        })
      ],
      alignment: AlignmentType.CENTER,
      spacing: { before: 600 }
    })
  ];
}

// === YARDIMCI FONKSƒ∞YONLAR ===

function createInfoCell(label, value) {
  return new TableCell({
    children: [
      new Paragraph({
        children: [
          new TextRun({ text: label, bold: true }),
          new TextRun({ text: ` ${value}` })
        ]
      })
    ],
    width: { size: 50, type: WidthType.PERCENTAGE }
  });
}

function createSummaryHeaderCell(text) {
  return new TableCell({
    children: [
      new Paragraph({
        children: [
          new TextRun({
            text: text,
            bold: true,
            color: "FFFFFF",
            size: 24
          })
        ],
        alignment: AlignmentType.CENTER
      })
    ],
    shading: { fill: "2E4BC7", type: "clear", color: "auto" }
  });
}

function createSummaryCell(text) {
  return new TableCell({
    children: [
      new Paragraph({
        children: [new TextRun({ text: text, size: 22 })],
        alignment: AlignmentType.CENTER
      })
    ],
    shading: { fill: "F8F9FA", type: "clear", color: "auto" }
  });
}

function createDetailCell(label, value) {
  return new TableCell({
    children: [
      new Paragraph({
        children: [
          new TextRun({ text: label, bold: true, size: 22 }),
          new TextRun({ text: ` ${value}`, size: 22 })
        ]
      })
    ],
    width: { size: 50, type: WidthType.PERCENTAGE },
    shading: { fill: "F8F9FA", type: "clear", color: "auto" }
  });
}

function createTableHeaderCell(text) {
  return new TableCell({
    children: [
      new Paragraph({
        children: [
          new TextRun({
            text: text,
            bold: true,
            color: "FFFFFF",
            size: 24
          })
        ],
        alignment: AlignmentType.CENTER
      })
    ],
    shading: { fill: "495057", type: "clear", color: "auto" }
  });
}

function createTableDataCell(text) {
  return new TableCell({
    children: [
      new Paragraph({
        children: [new TextRun({ text: text || "-", size: 22 })]
      })
    ]
  });
}

function sanitizeFileName(fileName) {
  return fileName.replace(/[<>:"/\\|?*]/g, '_').substring(0, 100);
}

// KULLANICI VE ADMIN Y√ñNETƒ∞Mƒ∞ //

const strip = (s) => String(s ?? '').trim().replace(/^["'\s]+|["'\s]+$/g, '');

function canManageUsers(req) {
  console.log('üîç Auth debug:', {
    hasAuth: !!req.auth,
    uid: req.auth?.uid,
    email: req.auth?.token?.email,
    role: req.auth?.token?.role,
    allClaims: req.auth?.token
  });
  
  if (!req.auth) return false;
  
  // Normal kontroller
  const claims = req.auth.token;
  const role = claims?.role;
  const email = claims?.email;
  const uid = req.auth.uid;
  
  // 1. S√ºper admin claim kontrol√º
  if (role === 'superadmin') {
    console.log('‚úÖ Access granted via superadmin role');
    return true;
  }
  
  // 2. Specific UID kontrol√º (backup)
  if (uid === 'wH6MFM3jrYShxWDPkjr0Lbuj61F2') {
    console.log('‚úÖ Access granted via specific UID');
    return true;
  }
  
  // 3. E-posta kontrol√º (backup)
  if (email && email.includes('@evrekapatent.com')) {
    console.log('‚úÖ Access granted via company email');
    return true;
  }
  
  console.log('‚ùå Access denied');
  return false;
}

// === Kullanƒ±cƒ± Olu≈ütur/G√ºncelle (Auth + Firestore senkron) ===
export const adminUpsertUser = onCall({ region: "europe-west1" }, async (req) => {
  if (!canManageUsers(req)) {
    throw new HttpsError("permission-denied", "Yetkisiz istek.");
  }

  const uidInput      = strip(req.data?.uid);
  const emailInput    = strip(req.data?.email).toLowerCase();
  const newEmailInput = strip(req.data?.newEmail).toLowerCase();   // opsiyonel
  const displayName   = strip(req.data?.displayName);
  console.log('üîç Backend received:', { 
    displayName, 
    emailInput,
    hasDisplayName: !!displayName 
});
  const role          = strip(req.data?.role || "user");
  const password      = String(req.data?.password || "");          // opsiyonel
  const disabledFlag  = req.data?.disabled;                         // opsiyonel (true/false)

  if (!uidInput && !emailInput) {
    throw new HttpsError("invalid-argument", "uid veya email zorunlu.");
  }
  if (!displayName) {
    throw new HttpsError("invalid-argument", "displayName zorunlu.");
  }

  // 1) Kullanƒ±cƒ±yƒ± bul (uid veya email) ‚Äî yoksa olu≈ütur
  let userRecord;
  let existed = true;
  try {
    userRecord = uidInput
      ? await adminAuth.getUser(uidInput)
      : await adminAuth.getUserByEmail(emailInput);
  } catch (e) {
    if (e?.code === "auth/user-not-found") {
      existed = false;
    } else {
      throw new HttpsError("internal", `Kullanƒ±cƒ± sorgulanamadƒ±: ${e?.message || e}`);
    }
  }

  if (!existed) {
    const createParams = { email: emailInput, displayName };
    if (password) createParams.password = password;
    userRecord = await adminAuth.createUser(createParams);
  }

  // 2) G√ºncelleme parametreleri
  const updateParams = {};
  if (displayName && displayName !== userRecord.displayName) updateParams.displayName = displayName;
  if (typeof disabledFlag === "boolean" && disabledFlag !== userRecord.disabled) updateParams.disabled = disabledFlag;
  if (password) updateParams.password = password;

  // E-posta deƒüi≈üikliƒüi (√ßakƒ±≈üma kontrol√º ile)
  const targetEmail = newEmailInput || emailInput || userRecord.email || "";
  if (targetEmail && targetEmail !== userRecord.email) {
    try {
      const other = await adminAuth.getUserByEmail(targetEmail);
      if (other.uid !== userRecord.uid) {
        throw new HttpsError("already-exists", "Bu e-posta ba≈üka bir kullanƒ±cƒ±da kayƒ±tlƒ±.");
      }
    } catch (e) {
      if (e?.code !== "auth/user-not-found") {
        throw new HttpsError("internal", `E-posta kontrol√º ba≈üarƒ±sƒ±z: ${e?.message || e}`);
      }
      // user-not-found ise hedef e-posta kullanƒ±labilir demektir
    }
    updateParams.email = targetEmail;
  }

  // 3) Auth g√ºncelle
  if (Object.keys(updateParams).length) {
    userRecord = await adminAuth.updateUser(userRecord.uid, updateParams);
  }

  // 4) Custom claims (rol)
  if (role) {
    await adminAuth.setCustomUserClaims(userRecord.uid, { role });
  }

  // 5) Firestore profilini upsert et
  await adminDb.collection("users").doc(userRecord.uid).set(
    {
      email: userRecord.email,
      displayName: userRecord.displayName || displayName,
      role,
      disabled: !!userRecord.disabled,
      updatedAt: FieldValue.serverTimestamp(),
      ...(existed ? {} : { createdAt: FieldValue.serverTimestamp() }),
    },
    { merge: true }
  );

  return {
    uid: userRecord.uid,
    email: userRecord.email,
    existed,
    role,
    disabled: !!userRecord.disabled,
  };
});

export const onAuthUserCreate = auth.user().onCreate(async (user) => {
  // Email'den ad √ßƒ±kar veya varsayƒ±lan kullan
  const displayName = user.displayName || 
                      user.email?.split('@')[0]?.replace(/[._-]/g, ' ') || 
                      'Yeni Kullanƒ±cƒ±';
  
  console.log(`üÜî Creating user profile: ${user.uid}, email: ${user.email}, displayName: "${displayName}"`);
  
  // 1. Firestore'a kaydet
  await adminDb.collection('users').doc(user.uid).set({
    email: user.email || '',
    displayName: displayName,
    role: 'belirsiz',
    disabled: !!user.disabled,
    createdAt: FieldValue.serverTimestamp(),
    updatedAt: FieldValue.serverTimestamp(),
    _source: 'auth.user().onCreate'
  }, { merge: true });
  
  // 2. Custom claim olarak da "belirsiz" rol√º ata
  await adminAuth.setCustomUserClaims(user.uid, { role: 'belirsiz' });
  
  console.log(`‚úÖ User profile created successfully for ${user.uid} with role: belirsiz`);
});

export const onAuthUserDelete = auth.user().onDelete(async (user) => {
  await adminDb.collection('users').doc(user.uid).delete().catch(() => {});
});


export const adminDeleteUser = onCall({ region: "europe-west1" }, async (req) => {
  if (!canManageUsers(req)) {
    throw new HttpsError("permission-denied", "Yetkisiz istek.");
  }

  const uid = strip(req.data?.uid);
  if (!uid) throw new HttpsError("invalid-argument", "uid zorunlu.");

  const callerUid = req.auth?.uid;
  if (uid === callerUid) {
    throw new HttpsError("failed-precondition", "Kendi hesabƒ±nƒ±zƒ± silemezsiniz.");
  }

  // 1) Auth'tan sil ‚Äì hatalarƒ± kontroll√º map et
  try {
    await adminAuth.deleteUser(uid);
  } catch (e) {
    if (e?.code === "auth/user-not-found") {
      // Auth'ta yoksa bile Firestore'u temizleyip OK d√∂nelim
      await adminDb.collection("users").doc(uid).delete().catch(() => {});
      return { ok: true, uid, note: "auth user not found; firestore cleaned" };
    }
    throw new HttpsError("internal", "Auth delete failed: " + (e?.message || e));
  }

  // 2) Firestore profilini sil (yoksa sorun deƒüil)
  await adminDb.collection("users").doc(uid).delete().catch(() => {});

  // 3) (opsiyonel) Bu kullanƒ±cƒ±ya atanmƒ±≈ü i≈üleri bo≈üaltmak istiyorsan burada yap
  // const qs = await adminDb.collection('tasks').where('assignedTo_uid', '==', uid).get();
  // const w = db.bulkWriter();
  // qs.forEach(d => w.update(d.ref, { assignedTo_uid: null, assignedTo_email: null }));
  // await w.close();

  return { ok: true, uid };
});

// ====== IMPORTS ======
import puppeteer from 'puppeteer-core';
import chromium from '@sparticuz/chromium';
import { getApps, initializeApp } from 'firebase-admin/app';
import { getStorage } from 'firebase-admin/storage';
chromium.setHeadlessMode = true;
chromium.setGraphicsMode = false;

// Ensure admin is initialized once
if (!getApps().length) {
  initializeApp();
}

// Basit bellek i√ßi cache ve cookie jar (aynƒ± instance ya≈üadƒ±ƒüƒ± s√ºrece ge√ßerli)
const __tpCache   = global.__tpCache   || (global.__tpCache   = new Map());
const __cookieJar = global.__cookieJar || (global.__cookieJar = new Map());

// K√º√ß√ºk yardƒ±mcƒ±lar
const sleep = (ms) => new Promise(r => setTimeout(r, ms));
const loadCookiesFor = (key) => __cookieJar.get(key) || [];
const saveCookiesFor = (key, cookies) => __cookieJar.set(key, cookies);

// ====== Data URL parse helper ======
function parseDataUrl(dataUrl) {
  const m = String(dataUrl).match(/^data:(image\/[a-zA-Z0-9.+-]+);base64,(.+)$/);
  if (!m) throw new Error('Ge√ßersiz data URL');
  const contentType = m[1];
  const base64 = m[2];
  const buffer = Buffer.from(base64, 'base64');
  const ext = contentType.split('/')[1].replace('jpeg', 'jpg');
  return { contentType, buffer, ext };
}

// ====== G√∂rseli Storage'a yazan yardƒ±mcƒ± ======
async function persistImageToStorage(src, applicationNumber) {
  try {
    const bucket = getStorage().bucket();
    const safeAppNo = String(applicationNumber || 'unknown').replace(/[^\w-]/g, '_');
    let buffer, contentType, ext;

    if (String(src).startsWith('data:')) {
      const parsed = parseDataUrl(src);
      buffer = parsed.buffer;
      contentType = parsed.contentType;
      ext = parsed.ext;
    } else {
      // HTTP(S) kaynaƒüƒ±nƒ± indir
      const resp = await fetch(src);
      if (!resp.ok) throw new Error(`Resim indirilemedi: ${resp.status}`);
      const arrayBuf = await resp.arrayBuffer();
      buffer = Buffer.from(arrayBuf);
      contentType = resp.headers.get('content-type') || 'image/jpeg';
      ext = contentType.split('/')[1]?.replace('jpeg', 'jpg') || 'jpg';
    }

    const filePath = `trademarks/${safeAppNo}/logo.${ext}`;
    const file = bucket.file(filePath);
    await file.save(buffer, {
      contentType,
      resumable: false,
      metadata: { cacheControl: 'public,max-age=31536000' },
    });

    // ƒ∞mzalƒ± URL (2035'e kadar)
    const [signedUrl] = await file.getSignedUrl({
      action: 'read',
      expires: '2035-01-01',
    });

    return { imagePath: filePath, imageSignedUrl: signedUrl, publicImageUrl: `https://storage.googleapis.com/${bucket.name}/${filePath}` };
  } catch (e) {
    logger.warn('G√∂rsel Storage‚Äôa kaydedilemedi, data URL d√∂nd√ºr√ºlecek.', { message: e?.message });
    return { imagePath: '', imageSignedUrl: '', publicImageUrl: '' };
  }
}

// ====== reCAPTCHA tespiti (bypass YOK) ======
async function detectCaptcha(page) {
  const text = (await page.evaluate(() => document.body.innerText || '')).toLowerCase();
  return /recaptcha|ben robot deƒüilim|i'm not a robot|l√ºtfen doƒürulayƒ±n/.test(text);
}

// ====== MUI tablolarƒ±nƒ± DOM'dan parse eden fonksiyon ======
function domParseFn() {
  const out = {
    applicationNumber:null, applicationDate:null, registrationNumber:null, registrationDate:null,
    intlRegistrationNumber:null, documentNumber:null, bulletinDate:null, bulletinNo:null,
    regBulletinDate:null, regBulletinNo:null, protectionDate:null, status:null, priorityInfo:null,
    niceClasses:[], type:null, trademarkName:null, agentInfo:null, ownerId:null, owner:null, ownerAddress:null,
    decision:null, decisionReason:null, goods:[], imageUrl:null, found:false
  };

  const normDate = (s) => {
    const m = (s||'').match(/\b(\d{2})[./](\d{2})[./](\d{4})\b/);
    return m ? `${m[3]}-${m[2]}-${m[1]}` : (s || null);
  };
  const txt = (n) => (n && (n.textContent || '')).trim();
  const dashToEmpty = (v) => (v === '-' ? '' : v);

  const tables = Array.from(document.querySelectorAll('table.MuiTable-root'));
  if (!tables.length) return out;

  // 1) √ñzet tablo (label/value)
  const t0 = tables[0];
  const rows0 = t0.querySelectorAll('tbody tr');

  rows0.forEach(tr => {
    const tds = Array.from(tr.querySelectorAll('td'));
    if (tds.length === 2) {
      const label = txt(tds[0]).toLowerCase();
      const cell  = tds[1];
      const raw   = txt(cell);
      const val   = dashToEmpty(raw);

      if (label.includes('marka adƒ±')) out.trademarkName = val;
      else if (label.includes('sahip bilgileri')) {
        const ps = Array.from(cell.querySelectorAll('p')).map(txt).filter(Boolean);
        out.ownerId = ps[0] || null;
        out.owner = ps[1] || null;
        out.ownerAddress = ps.slice(2).join(' ') || null;
      }
      else if (label.includes('r√º√ßhan bilgileri')) out.priorityInfo = val;
    } else if (tds.length === 4) {
      const label1 = txt(tds[0]).toLowerCase(), value1 = dashToEmpty(txt(tds[1]));
      const label2 = txt(tds[2]).toLowerCase(), value2 = dashToEmpty(txt(tds[3]));

      // --- √ñNCE daha spesifik olanlarƒ± kontrol et ---
      if (label1.includes('uluslararasƒ± tescil numarasƒ±')) out.intlRegistrationNumber = value1;
      else if (label1.includes('tescil numarasƒ±')) out.registrationNumber = value1;
      else if (label1.includes('ba≈üvuru numarasƒ±')) out.applicationNumber = value1;
      else if (label1.includes('marka ilan b√ºlten tarihi')) out.bulletinDate = normDate(value1);
      else if (label1.includes('marka ilan b√ºlten no')) out.bulletinNo = value1;
      else if (label1.includes('tescil yayƒ±n b√ºlten tarihi')) out.regBulletinDate = normDate(value1);
      else if (label1.includes('tescil yayƒ±n b√ºlten no')) out.regBulletinNo = value1;
      else if (label1.includes('koruma tarihi')) out.protectionDate = normDate(value1);
      else if (label1.includes('nice sƒ±nƒ±flarƒ±')) {
        out.niceClasses = (value1 || '')
          .split(/[^\d]+/)
          .map(s => s.trim())
          .filter(Boolean);
      } else if (label1.includes('karar')) out.decision = value1;

      if (label2.includes('uluslararasƒ± tescil numarasƒ±')) out.intlRegistrationNumber = value2;
      else if (label2.includes('tescil numarasƒ±')) out.registrationNumber = value2;
      else if (label2.includes('ba≈üvuru tarihi')) out.applicationDate = normDate(value2);
      else if (label2.includes('tescil tarihi')) out.registrationDate = normDate(value2);
      else if (label2.includes('evrak numarasƒ±')) out.documentNumber = value2;
      else if (label2.includes('tescil yayƒ±n b√ºlten tarihi')) out.regBulletinDate = normDate(value2);
      else if (label2.includes('tescil yayƒ±n b√ºlten no')) out.regBulletinNo = value2;
      else if (label2.includes('marka ilan b√ºlten tarihi')) out.bulletinDate = normDate(value2);
      else if (label2.includes('marka ilan b√ºlten no')) out.bulletinNo = value2;
      else if (label2.includes('durumu')) out.status = value2;
      else if (label2 === 't√ºr√º') out.type = value2;
      else if (label2.includes('karar gerek√ßesi')) out.decisionReason = value2;
    }
  });

  // 2) GOODS tablosunu THEAD ba≈ülƒ±ƒüƒ±yla tespit et
  const goodsTable = tables.find(t => {
    const ths = Array.from(t.querySelectorAll('thead th'));
    return ths.length >= 2 &&
           /sƒ±nƒ±f/i.test(txt(ths[0])) &&
           /mal ve hizmetler/i.test(txt(ths[1]));
  });

  if (goodsTable) {
    const rows1 = goodsTable.querySelectorAll('tbody tr');
    rows1.forEach(tr => {
      const tds = tr.querySelectorAll('td');
      const cls = txt(tds[0]);
      const desc = txt(tds[1]);
      if (cls) out.goods.push({ class: cls, description: desc });
    });
  }

  // 3) G√∂rsel (data URL veya URL)
  const scope = t0.closest('section,div,main') || document;
  const img = scope.querySelector('img[alt*="Marka"], img[src^="data:image"], img[src*="resim"], img[src*="marka"], .trademark-image img');
  if (img && img.src && !/icon|logo|button|avatar/i.test(img.src)) {
    try { out.imageUrl = new URL(img.src, location.href).href; }
    catch { out.imageUrl = img.src; }
  }

  out.found = !!(out.trademarkName || out.applicationNumber || out.registrationNumber);
  return out;
}

// ====== COMMON HANDLER ======
async function handleScrapeTrademark(basvuruNo) {
  if (!basvuruNo) {
    throw new HttpsError('invalid-argument', 'Ba≈üvuru numarasƒ± (basvuruNo) zorunludur.');
  }

  logger.info('[scrapeTrademarkPuppeteer] Ba≈ülƒ±yor', { basvuruNo });

  // ---- 0) 5 dk Cache ----
  const cached = __tpCache.get(basvuruNo);
  if (cached && (Date.now() - cached.ts) < 5 * 60 * 1000) {
    logger.info('Cache hit, 5 dk i√ßindeki sonucu d√∂nd√ºr√ºyorum.');
    return cached.data;
  }

  // ---- 1) Global oran sƒ±nƒ±rlama (45‚Äì60 sn jitter) ----
  const lastRequestKey = 'turkpatent_last_request';
  const minDelay = 45000 + Math.floor(Math.random() * 15000);
  const lastRequest = global[lastRequestKey] || 0;
  const elapsed = Date.now() - lastRequest;
  if (elapsed < minDelay) {
    const waitTime = minDelay - elapsed;
    logger.info(`Rate limiting: ${waitTime}ms bekleyecek`);
    await sleep(waitTime);
  }
  global[lastRequestKey] = Date.now();

  // ---- 2) Global BACKOFF ----
  const tpBackoffKey = 'turkpatent_backoff_until';
  const backoffRemaining = Math.max(0, (global[tpBackoffKey] || 0) - Date.now());
  if (backoffRemaining > 0) {
    const retryAfterSec = Math.ceil(backoffRemaining / 1000);
    logger.info(`Backoff aktif, ${retryAfterSec}s sonra tekrar deneyin.`);
    return {
      status: 'Backoff',
      found: false,
      applicationNumber: basvuruNo,
      retryAfterSec,
      message: 'T√ºrkPatent ge√ßici limitten dolayƒ± bekleme s√ºresi aktif.'
    };
  }

  let browser;
  let page;

  try {
const isLocal = process.env.FUNCTIONS_EMULATOR === 'true';

const launchOptions = isLocal ? {
  headless: true,
  executablePath: process.env.CHROME_PATH || await chromium.executablePath(),
  args: ['--no-sandbox', '--disable-setuid-sandbox'],
  defaultViewport: { width: 1920, height: 1080 }
} : {
  headless: chromium.headless,
  executablePath: await chromium.executablePath(),
  args: [
    ...chromium.args,
    '--disable-dev-shm-usage',
    '--disable-gpu',
    '--no-first-run',
    '--disable-default-apps',
    '--disable-features=VizDisplayCompositor',
    '--disable-blink-features=AutomationControlled',
    '--disable-web-security'
  ],
  defaultViewport: { width: 1920, height: 1080 }
};


    const browser = await puppeteer.launch({
      args: [...chromium.args, '--no-sandbox', '--disable-setuid-sandbox'],
      defaultViewport: chromium.defaultViewport,
      executablePath: await chromium.executablePath(),  // üî¥ kritik satƒ±r
      headless: chromium.headless,
      ignoreHTTPSErrors: true,
      protocolTimeout: 180000
    });

    page = await browser.newPage();

    // --- Stealth / Kimlik ayarlarƒ± ---
    await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36');
    await page.setExtraHTTPHeaders({ 'Accept-Language': 'tr-TR,tr;q=0.9,en-US;q=0.8,en;q=0.7' });
    try { await page.emulateTimezone('Europe/Istanbul'); } catch {}
    await page.evaluateOnNewDocument(() => {
      Object.defineProperty(navigator, 'webdriver', { get: () => false });
    });

    // --- Cookie reuse ---
    const savedCookies = loadCookiesFor('turkpatent');
    if (savedCookies.length) {
      try { await page.setCookie(...savedCookies); } catch {}
    }

    // Network monitoring ve request interceptor
      await page.setRequestInterception(true);
      
      page.on('request', (request) => {
        logger.info('Request:', request.url(), request.method());
        const resourceType = request.resourceType();
        if (['image', 'stylesheet', 'font', 'media'].includes(resourceType)) {
          request.abort();
        } else {
          request.continue();
        }
      });

      page.on('response', (response) => {
        if (response.url().includes('turkpatent') || response.url().includes('api') || response.url().includes('search')) {
          logger.info('Response:', response.url(), response.status());
        }
      });

    page.setDefaultTimeout(30000);
    page.setDefaultNavigationTimeout(30000);

    logger.info('[scrapeTrademarkPuppeteer] Sayfaya gidiliyor...');
    await page.goto('https://www.turkpatent.gov.tr/arastirma-yap?form=trademark', { waitUntil: 'domcontentloaded' });

    // --- Popup/Modal kapat ---
    try {
      try { await page.waitForSelector('.jss84 .jss92', { timeout: 2000 }); await page.click('.jss84 .jss92'); } catch {}
      try {
        await page.waitForSelector('[role="dialog"], .MuiDialog-root, .MuiModal-root', { timeout: 2000 });
        const closeBtn = await page.$('button[aria-label="Close"], button[aria-label="Kapat"], .close');
        if (closeBtn) { await closeBtn.click(); }
      } catch {}
    } catch (modalError) {
      logger.info('Modal kapatma hatasƒ± (normal):', { message: modalError?.message });
    }

    // --- "Dosya Takibi" sekmesi ---
    try {
      await page.evaluate(() => {
        const buttons = document.querySelectorAll('button[role="tab"]');
        for (const btn of buttons) {
          if (btn.textContent && btn.textContent.includes('Dosya Takibi')) {
            if (btn.getAttribute('aria-selected') !== 'true') btn.click();
            return;
          }
        }
      });
      await page.waitForSelector('input[placeholder="Ba≈üvuru Numarasƒ±"]', { timeout: 5000 });
      logger.info('Dosya Takibi sekmesine ge√ßi≈ü ba≈üarƒ±lƒ±.');
    } catch (tabError) {
      logger.error('Dosya Takibi sekmesine ge√ßi≈ü hatasƒ±:', { message: tabError?.message });
      throw new HttpsError('internal', `Tab ge√ßi≈üi ba≈üarƒ±sƒ±z: ${tabError.message}`);
    }

    // --- Form doldur ---
    logger.info('[scrapeTrademarkPuppeteer] Form doldurma i≈ülemi...');
    try {
      await page.waitForSelector('input[placeholder="Ba≈üvuru Numarasƒ±"]', { timeout: 5000 });
      const input = await page.$('input[placeholder="Ba≈üvuru Numarasƒ±"]');
      if (!input) throw new Error('Ba≈üvuru numarasƒ± input alanƒ± bulunamadƒ±');

      await input.click({ clickCount: 3 });
      await input.type(basvuruNo);
      await page.evaluate((inputEl, value) => {
        inputEl.value = value;
        inputEl.dispatchEvent(new Event('input', { bubbles: true }));
        inputEl.dispatchEvent(new Event('change', { bubbles: true }));
      }, input, basvuruNo);

      logger.info(`Ba≈üvuru numarasƒ± yazƒ±ldƒ±: ${basvuruNo}`);
    } catch (inputError) {
      logger.error('Form doldurma hatasƒ±:', { message: inputError?.message });
      throw new HttpsError('internal', `Form doldurma ba≈üarƒ±sƒ±z: ${inputError.message}`);
    }

    // --- TEK TIK + DOM BEKLEME (JSON YOK) ---
    logger.info('[scrapeTrademarkPuppeteer] Sorgula butonu tƒ±klanƒ±yor ve DOM bekleniyor...');
    await sleep(400 + Math.floor(Math.random() * 600)); // k√º√ß√ºk jitter

    const clicked = await page.evaluate(() => {
      const btn = Array.from(document.querySelectorAll('button'))
        .find(b => /sorgula/i.test((b.textContent || '')) && !b.disabled && !b.getAttribute('aria-disabled'));
      if (!btn) return false;
      btn.click();
      return true;
    });
    if (!clicked) throw new HttpsError('internal', 'Sorgula butonu bulunamadƒ±');

    // Captcha kontrol√º (bypass yok; anlamlƒ± d√∂n√º≈ü)
    if (await detectCaptcha(page)) {
      const retryAfterSec = 120 + Math.floor(Math.random()*60);
      global['turkpatent_backoff_until'] = Date.now() + retryAfterSec * 1000;
      return {
        status: 'CaptchaRequired',
        found: false,
        applicationNumber: basvuruNo,
        retryAfterSec,
        message: 'reCAPTCHA doƒürulamasƒ± gerekiyor. L√ºtfen doƒürulayƒ±p tekrar deneyin.'
      };
    }

    // DOM y√ºklenmesini bekle
    await page.waitForSelector('table#results tbody tr', { timeout: 60000 });

    // DOM'dan veriyi √ßek
    const tdata = await page.evaluate(domParseFn);

    // Basit hata metni taramasƒ±
    const hasError = await page.evaluate(() => {
      const els = document.querySelectorAll('.error, .alert-danger, .MuiAlert-message, p, div, span, h1, h2, h3');
      const keys = ['bulunamadƒ±','sonu√ß yok','hata','ge√ßersiz','√ßok fazla deneme','too many attempts','rate limit','sistem me≈ügul','ge√ßici olarak hizmet dƒ±≈üƒ±'];
      for (const el of Array.from(els)) {
        const t = (el.textContent || '').trim().toLowerCase();
        if (keys.some(k => t.includes(k))) return (el.textContent || '').trim();
      }
      return null;
    });

    if (hasError) {
      return { applicationNumber: basvuruNo, found: false, status: 'NotFound', message: hasError, error: hasError };
    }

    if (!tdata?.found) {
      const pageTitle = await page.title();
      return { applicationNumber: basvuruNo, found: false, status: 'DataExtractionError', message: 'Sayfa y√ºklendi ancak veri √ßƒ±karƒ±lamadƒ±', pageTitle };
    }

    // Normalizasyon
    const normalized = {
      applicationNumber: tdata.applicationNumber || basvuruNo,
      applicationDate:  tdata.applicationDate || '',
      trademarkName:    tdata.trademarkName || '',
      imageUrl:         tdata.imageUrl || '',
      owner:            tdata.owner || '',
      status:           tdata.status || '',
      niceClasses:      Array.isArray(tdata.niceClasses) ? tdata.niceClasses : [],

      // ek alanlar
      registrationNumber:        tdata.registrationNumber || '',
      registrationDate:          tdata.registrationDate || '',
      intlRegistrationNumber:    tdata.intlRegistrationNumber || '',
      documentNumber:            tdata.documentNumber || '',
      bulletinDate:              tdata.bulletinDate || '',
      bulletinNo:                tdata.bulletinNo || '',
      regBulletinDate:           tdata.regBulletinDate || '',
      regBulletinNo:             tdata.regBulletinNo || '',
      protectionDate:            tdata.protectionDate || '',
      type:                      tdata.type || '',
      ownerId:                   tdata.ownerId || '',
      ownerAddress:              tdata.ownerAddress || '',
      agentInfo:                 tdata.agentInfo || '',
      decision:                  tdata.decision || '',
      decisionReason:            tdata.decisionReason || '',
      goods:                     Array.isArray(tdata.goods) ? tdata.goods : []
    };

    logger.info('Marka verisi DOM‚Äôdan √ßƒ±karƒ±ldƒ±', {
      applicationNumber: normalized.applicationNumber,
      applicationDate: normalized.applicationDate,
      trademarkName: normalized.trademarkName,
      hasImage: !!normalized.imageUrl,
      goodsCount: normalized.goods.length
    });

    // --- G√∂rsel varsa Storage'a yaz ve linkleri ekle ---
    if (normalized.imageUrl) {
      const { imagePath, imageSignedUrl, publicImageUrl } = await persistImageToStorage(normalized.imageUrl, normalized.applicationNumber);
      if (imagePath) {
        normalized.imagePath = imagePath;
        normalized.imageSignedUrl = imageSignedUrl;
        normalized.publicImageUrl = publicImageUrl;
        // UI kolaylƒ±ƒüƒ± i√ßin imageUrl'√º imzalƒ± URL ile deƒüi≈ütir
        normalized.imageUrl = imageSignedUrl || publicImageUrl || normalized.imageUrl;
      }
    }

    const result = { status: 'Success', found: true, data: normalized, ...normalized };
    __tpCache.set(basvuruNo, { ts: Date.now(), data: result });
    return result;

  } catch (err) {
    logger.error('[scrapeTrademarkPuppeteer] Genel hata', { message: err?.message, stack: err?.stack, basvuruNo });
    throw new HttpsError('internal', `Puppeteer hatasƒ±: ${err?.message || String(err)}`);
  } finally {
    // Cookie‚Äôleri sakla (ba≈üarƒ±lƒ±/ba≈üarƒ±sƒ±z fark etmez)
    try {
      // eslint-disable-next-line no-undef
      if (typeof page !== 'undefined' && page) {
        const freshCookies = await page.cookies();
        if (freshCookies?.length) saveCookiesFor('turkpatent', freshCookies);
      }
    } catch {}

    if (typeof browser !== 'undefined' && browser) {
      try { await browser.close(); logger.info('Browser kapatƒ±ldƒ±'); }
      catch (closeError) { logger.error('Browser kapatma hatasƒ±:', { message: closeError?.message }); }
    }
  }
}

// ====== CALLABLE (onCall) VERSƒ∞YONU ======
export const scrapeTrademark = onCall(
  { region: 'europe-west1', memory: '2GiB', timeoutSeconds: 180 },
  async (request) => {
    const basvuruNo = request.data?.basvuruNo;
    return await handleScrapeTrademark(basvuruNo);
  }
);
// ====== YENƒ∞LENMƒ∞≈û SAHƒ∞P NUMARASI ƒ∞LE TOPLU MARKA ARAMA (FOUND YALNIZCA SATIR VARSA) ======
// ====== YENƒ∞LENMƒ∞≈û SAHƒ∞P NUMARASI ƒ∞LE TOPLU MARKA ARAMA (iframe + role="number" + role-√∂ncelikli parse) ======
export const scrapeOwnerTrademarks = onCall(
  { region: 'europe-west1', memory: '2GiB', timeoutSeconds: 300 },
  async (request) => {
    const { ownerId, maxRetries = 2 } = request.data || {};
    if (!ownerId) {
      throw new HttpsError('invalid-argument', 'Sahip numarasƒ± (ownerId) zorunludur.');
    }

    logger.info('[scrapeOwnerTrademarks] Ba≈ülƒ±yor', { ownerId, maxRetries });

    const isLocal = !!process.env.FUNCTIONS_EMULATOR || (!process.env.K_SERVICE && process.env.NODE_ENV !== 'production');
    let browser;
    let retryCount = 0;

    while (retryCount < maxRetries) {
      try {
        logger.info(`Deneme ${retryCount + 1}/${maxRetries} ba≈ülƒ±yor...`);

        // === Browser Ba≈ülatma ===
        if (isLocal) {
          const puppeteerLocal = await import('puppeteer');
          browser = await puppeteerLocal.default.launch({
            headless: 'new',
            args: [
              '--no-sandbox',
              '--disable-setuid-sandbox',
              '--disable-dev-shm-usage',
              '--disable-blink-features=AutomationControlled',
            ],
            defaultViewport: { width: 1366, height: 900 },
          });
        } else {
          const execPath = await chromium.executablePath();
          browser = await puppeteer.launch({
            args: [
              ...chromium.args,
              '--no-sandbox',
              '--disable-setuid-sandbox',
              '--disable-dev-shm-usage',
              '--disable-blink-features=AutomationControlled',
            ],
            defaultViewport: chromium.defaultViewport || { width: 1366, height: 900 },
            executablePath: execPath,
            headless: chromium.headless,
            ignoreHTTPSErrors: true,
          });
        }

        const page = await browser.newPage();
        await page.setJavaScriptEnabled(true);
        await page.setUserAgent(
          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
        );

        // Basit bot-detection bypass
        await page.evaluateOnNewDocument(() => {
          Object.defineProperty(navigator, 'webdriver', { get: () => false });
          Object.defineProperty(navigator, 'plugins', { get: () => [1, 2, 3, 4, 5] });
          Object.defineProperty(navigator, 'languages', { get: () => ['tr-TR', 'tr', 'en-US', 'en'] });
          window.chrome = {
            runtime: {},
            loadTimes: function () { return { requestTime: Date.now() / 1000 }; },
            csi: function () { return { startE: Date.now(), onloadT: Date.now() }; },
          };
        });

        // Request interception - reCAPTCHA isteklerini engelle + hafif i√ßerik diyeti
        await page.setRequestInterception(true);
        page.on('request', (req) => {
          const url = req.url();
          const resourceType = req.resourceType();

          if (
            url.includes('recaptcha') ||
            url.includes('gstatic.com/recaptcha') ||
            url.includes('google.com/recaptcha')
          ) {
            logger.info('reCAPTCHA isteƒüi engellendi');
            req.abort();
            return;
          }

          if (['image', 'stylesheet', 'font', 'media', 'manifest'].includes(resourceType)) {
            req.abort();
          } else {
            req.continue();
          }
        });

        // Sayfayƒ± y√ºkle
        await page.goto('https://www.turkpatent.gov.tr/arastirma-yap', {
          waitUntil: 'domcontentloaded',
          timeout: 60000,
        });
        logger.info('Sayfa ba≈üarƒ±yla y√ºklendi.');

        // ƒ∞nsan benzeri k√º√ß√ºk davranƒ±≈ü
        await page.mouse.move(200, 200);
        await page.mouse.click(200, 200);
        await page.keyboard.type('test');
        await sleep(700);

        // === Form Doldurma ===
        await page.waitForSelector('input', { timeout: 10000 });

        const inputResult = await page.evaluate((val) => {
          const input =
            document.querySelector('input[placeholder*="Ki≈üi Numarasƒ±" i]') ||
            document.querySelector('input[placeholder*="ki≈üi" i]') ||
            Array.from(document.querySelectorAll('input')).find(
              (i) =>
                (i.placeholder || '').toLowerCase().includes('ki≈üi') ||
                (i.placeholder || '').toLowerCase().includes('numara')
            );
          if (!input) return { success: false, error: 'Ki≈üi Numarasƒ± inputu bulunamadƒ±' };

          input.focus();
          input.value = '';
          input.value = String(val);
          input.dispatchEvent(new Event('input', { bubbles: true }));
          input.dispatchEvent(new Event('change', { bubbles: true }));
          return { success: true };
        }, String(ownerId));

        if (!inputResult.success) {
          throw new Error(inputResult.error);
        }

        await sleep(600);

        // === Sorgula Butonuna Tƒ±klama ===
        const clickResult = await page.evaluate(() => {
          const btn = Array.from(document.querySelectorAll('button')).find(
            (b) => /sorgula/i.test((b.textContent || b.value || '').trim()) && !b.disabled
          );
          if (!btn) return { success: false, error: 'SORGULA butonu bulunamadƒ±' };
          btn.click();
          return { success: true };
        });

        if (!clickResult.success) {
          throw new Error(clickResult.error);
        }

        logger.info('Sorgula butonuna tƒ±klandƒ±, sonu√ßlar bekleniyor...');

        // === Selector listeleri (satƒ±r tespiti i√ßin) ===
        const rowSelectorList = [
          'table tbody tr[role="number"]',
          'table tbody tr',
          '.MuiTable-root tbody tr[role="number"]',
          '.MuiTable-root tbody tr',
          '[role="table"] tbody tr',
          // MUI DataGrid / virtualized:
          '[role="grid"] [role="row"]',
          '[role="rowgroup"] [role="row"]',
          'tbody tr[role="number"]',
          'tbody tr'
        ];

        // === Her frame‚Äôde satƒ±r var mƒ± kontrol√º (iframe-aware probe) ===
        async function probeAnyFrame(page) {
          const frames = [page.mainFrame(), ...page.frames()];
          for (const f of frames) {
            try {
              const res = await f.evaluate((selectors) => {
                const bodyText = (document.body.innerText || '').toLowerCase();

                const loadingKw = ['y√ºkleniyor', 'loading', 'bekleyin', 'aranƒ±yor'];
                const notFoundKw = ['0 kayƒ±t bulundu', 'kayƒ±t bulunamadƒ±', 'sonu√ß bulunamadƒ±', 'hi√ß kayƒ±t', 'sonu√ß yok'];
                const errKw = ['hata olu≈ütu', 'sistem hatasƒ±', 'ge√ßici hata'];

                const isLoading   = loadingKw.some(k => bodyText.includes(k));
                const hasNotFound = notFoundKw.some(k => bodyText.includes(k));
                const hasError    = errKw.some(k => bodyText.includes(k));

                let rowCount = 0, usedSelector = '';
                for (const sel of selectors) {
                  const n = document.querySelectorAll(sel).length;
                  if (n > 0) { rowCount = n; usedSelector = sel; break; }
                }

                // ƒ∞lk 2 satƒ±r √∂n izlemesi
                const firstRowsPreview = [];
                if (rowCount > 0) {
                  const trs = document.querySelectorAll(usedSelector);
                  const lim = Math.min(2, trs.length);
                  for (let i = 0; i < lim; i++) {
                    firstRowsPreview.push((trs[i].innerText || '').replace(/\s+/g, ' ').trim());
                  }
                }

                return { isLoading, hasNotFound, hasError, rowCount, usedSelector, firstRowsPreview };
              }, rowSelectorList);

              if (res?.rowCount > 0 || res?.hasNotFound || res?.hasError) {
                return { frame: f, ...res };
              }
            } catch {}
          }
          return null;
        }

        // === GELƒ∞≈ûTƒ∞Rƒ∞LMƒ∞≈û SONU√á BEKLEME: "found" sadece ger√ßek satƒ±r varsa ===
        let status = null;
        let foundFrame = null;
        const maxWaitTime = 120000; // 2 dk
        const pollEvery = 1500;
        const t0 = Date.now();

        while (Date.now() - t0 < maxWaitTime) {
          const p = await probeAnyFrame(page);
          if (p) {
            logger.info('[probe]', {
              rowCount: p.rowCount,
              usedSelector: p.usedSelector,
              isLoading: p.isLoading,
              hasNotFound: p.hasNotFound,
              hasError: p.hasError
            });

            if (p.rowCount > 0 && !p.isLoading) {
              status = 'found';
              foundFrame = p.frame;  // satƒ±rlar hangi frame‚Äôdeyse onu kullan
              logger.info('Sonu√ß durumu belirlendi: found (satƒ±r sayƒ±sƒ±: ' + p.rowCount + ')');
              if (p.firstRowsPreview?.length) logger.info('[rows-preview]', { rows: p.firstRowsPreview });
              break;
            }
            if (p.hasNotFound && !p.isLoading) { status = 'not_found'; break; }
            if (p.hasError) { status = 'error'; break; }
          }
          await sleep(pollEvery);
        }

        if (!status) {
          logger.warn('Timeout: Sonu√ß durumu belirlenemedi');
          status = 'timeout';
        }

        // Found ise en az bir satƒ±r g√∂r√ºnene kadar garanti bekleyelim
        if (status === 'found') {
          try {
            await (foundFrame || page).waitForSelector(
              'table tbody tr, .MuiTable-root tbody tr, [role="grid"] [role="row"]',
              { visible: true, timeout: 30000 }
            );
          } catch {}
        }

        // === SONU√á ƒ∞≈ûLEME / PARSE (role-√∂ncelikli + iframe-aware) ===
        if (status === 'found') {
          logger.info('Veri √ßekiliyor...');
          await sleep(800);

          const frameForParse = foundFrame || page.mainFrame();

          const { rows, rowCount, usedSelector } = await frameForParse.evaluate(() => {
            const norm = (s) => (s || '').replace(/\s+/g, ' ').trim();

            const selectors = [
              'table tbody tr[role="number"]',
              '.MuiTable-root tbody tr[role="number"]',
              '[role="table"] tbody tr[role="number"]',
              'table tbody tr',
              '.MuiTable-root tbody tr',
              '[role="table"] tbody tr',
              // fallback‚Äôlar:
              '[role="grid"] [role="row"]',
              '[role="rowgroup"] [role="row"]',
              'tbody tr[role="number"]',
              'tbody tr'
            ];

            let trs = [];
            let usedSelector = '';
            for (const sel of selectors) {
              const list = document.querySelectorAll(sel);
              if (list.length > 0) { trs = Array.from(list); usedSelector = sel; break; }
            }

            const rows = trs.map(tr => {
              // √ñnce role‚Äôl√º h√ºcre
              const byRole = (role) => {
                const el =
                  tr.querySelector(`td[role="${role}"]`) ||
                  tr.querySelector(`[role="cell"][data-field="${role}"]`);
                return el ? norm(el.innerText) : '';
              };

              // Sonra index fallback (ilk kolon numara/checkbox olabilir)
              let cells = Array.from(tr.querySelectorAll('td'));
              if (cells.length === 0) cells = Array.from(tr.querySelectorAll('[role="cell"]'));
              const get = (i) => (cells[i] ? norm(cells[i].innerText) : '');

              const applicationNumber = byRole('applicationNo')   || get(1) || get(0);
              const brandName        = byRole('markName')        || get(2) || get(1);
              const ownerName        = byRole('holdName')        || get(3) || get(2);
              const applicationDate  = byRole('applicationDate') || get(4) || get(3);
              const registrationNo   = byRole('registrationNo')  || get(5) || get(4);
              const state            = byRole('state')           || get(6) || get(5);
              const niceText         = byRole('niceClasses')     || get(7) || get(6);

              const niceList = (niceText || '')
                .split(/[^\d]+/)
                .map(x => x.trim())
                .filter(Boolean);

              const img = tr.querySelector('img') || tr.querySelector('picture img') || tr.querySelector('[role="cell"] img');
              const a   = tr.querySelector('a[href]');

              return {
                applicationNumber,
                brandName,
                ownerName,
                applicationDate,
                registrationNumber: registrationNo,
                status: state,
                niceClasses: niceText,
                niceList,
                imageUrl: img ? img.getAttribute('src') : '',
                detailUrl: a ? a.getAttribute('href') : ''
              };
            }).filter(r => r && (r.applicationNumber || r.brandName));

            return { rows, rowCount: trs.length, usedSelector };
          });

          logger.info(`[owner-scrape] Satƒ±r sayƒ±sƒ± (ham): ${rowCount} | Kullanƒ±lan selector: ${usedSelector}`);
          logger.info(`[owner-scrape] Parse sonrasƒ± kayƒ±t: ${rows.length}`);

          if (rows.length === 0) {
            // Te≈ühis i√ßin ilk satƒ±rdan kƒ±sa HTML kesiti
            try {
              const snippet = await (foundFrame || page).evaluate((sel) => {
                const tr = document.querySelector(sel);
                if (!tr) return '';
                const html = tr.outerHTML || '';
                return html.slice(0, 600);
              }, usedSelector);
              if (snippet) logger.info('[first-tr-html-snippet]', { snippet });
            } catch {}

            return {
              status: 'NotFound',
              found: false,
              ownerId,
              count: 0,
              message: 'Tablo bulundu ancak veri yok'
            };
          }

          return {
            status: 'Success',
            found: true,
            count: rows.length,
            ownerId,
            items: rows
          };

        } else if (status === 'not_found') {
          logger.info('Kayƒ±t bulunamadƒ±.');
          return {
            status: 'NotFound',
            found: false,
            ownerId,
            count: 0,
            message: 'Belirtilen sahip numarasƒ± i√ßin kayƒ±t bulunamadƒ±.'
          };

        } else {
          throw new Error(`Beklenmeyen durum: ${status}`);
        }

      } catch (err) {
        logger.error(`[scrapeOwnerTrademarks] Deneme ${retryCount + 1} hatasƒ±:`, { message: err?.message });

        // Screenshot al (debug)
        if (browser) {
          try {
            const pages = await browser.pages();
            if (pages.length > 0) {
              const screenshot = await pages[0].screenshot({ encoding: 'base64', quality: 30 });
              if (screenshot) logger.info('Hata screenshot alƒ±ndƒ±');
            }
          } catch (e) {
            logger.warn('Screenshot alƒ±namadƒ±:', e.message);
          }
        }

        if (retryCount >= maxRetries - 1) {
          throw new HttpsError('internal', `Owner arama hatasƒ± (${maxRetries} deneme): ${err?.message || String(err)}`);
        }

        retryCount++;
        logger.info(`${retryCount + 1}. deneme i√ßin bekleniyor...`);
        await sleep(5000 * retryCount);

      } finally {
        if (browser) {
          try {
            await browser.close();
            browser = null;
            logger.info('Browser kapatƒ±ldƒ±');
          } catch (e) {
            logger.warn('Browser kapatma hatasƒ±:', e.message);
          }
        }
      }
    }

    throw new HttpsError('internal', 'T√ºm denemeler ba≈üarƒ±sƒ±z oldu');
  }
);

// =========================================================
//              YENƒ∞: YENƒ∞LEME OTOMASYON FONKSƒ∞YONU
// =========================================================

/**
 * Portf√∂y kayƒ±tlarƒ±ndaki yenileme tarihlerini kontrol ederek
 * yeni yenileme g√∂revleri olu≈üturan callable fonksiyon.
 * Kurallar:
 * - taskType: '22'
 * - ipRecords status "ge√ßersiz" veya "rejected" olmamalƒ±
 * - Yenileme tarihi bug√ºnden 6 ay √∂nce veya sonraki aralƒ±ƒüa girmeli
 * - WIPO/ARIPO kayƒ±tlarƒ± i√ßin sadece 'parent' hiyerar≈üisindekiler i≈üleme alƒ±nƒ±r.
 * - Atama, taskAssignments koleksiyonundaki kurala g√∂re yapƒ±lƒ±r.
 */
async function resolveApprovalAssignee(adminDb, taskTypeId = "22") {
  const out = { uid: null, email: null, reason: "unknown" };

  const snap = await adminDb.collection("taskAssignments").doc(String(taskTypeId)).get();
  if (!snap.exists) { out.reason = "rule-missing"; return out; }

  const rule = snap.data() || {};
  const list = Array.isArray(rule.approvalStateAssigneeIds) ? rule.approvalStateAssigneeIds : [];
  if (!list.length) { out.reason = "approvalStateAssigneeIds-empty"; return out; }

  const uid = String(list[0]);
  const userSnap = await adminDb.collection("users").doc(uid).get();
  if (!userSnap.exists) { out.reason = "user-missing"; return out; }

  const email = userSnap.data()?.email || null;
  if (!email) { out.reason = "email-missing"; return out; }

  return { uid, email, reason: "ok" };
}
export const checkAndCreateRenewalTasks = onCall({ region: "europe-west1" }, async (request) => {
  logger.log('üîÑ Renewal task check started manually with updated rules');

  const taskTypeId = "22";
  const TODAY = new Date();
  const sixMonthsAgo = new Date();  sixMonthsAgo.setMonth(TODAY.getMonth() - 6);
  const sixMonthsLater = new Date(); sixMonthsLater.setMonth(TODAY.getMonth() + 6);

  // 1) Atama: yalnƒ±zca approvalStateAssigneeIds
  let assignedTo_uid = null;
  let assignedTo_email = null;
  try {
    const ruleSnap = await adminDb.collection("taskAssignments").doc(taskTypeId).get();
    if (!ruleSnap.exists) throw new HttpsError("failed-precondition", "taskAssignments/22 bulunamadƒ±");

    const rule = ruleSnap.data() || {};
    const approvalIds = Array.isArray(rule.approvalStateAssigneeIds) ? rule.approvalStateAssigneeIds : [];
    if (!approvalIds.length) throw new HttpsError("failed-precondition", "approvalStateAssigneeIds bo≈ü");

    const uid = String(approvalIds[0]);
    const userSnap = await adminDb.collection("users").doc(uid).get();
    if (!userSnap.exists) throw new HttpsError("failed-precondition", `users/${uid} bulunamadƒ±`);
    const email = userSnap.data()?.email || null;
    if (!email) throw new HttpsError("failed-precondition", `users/${uid} i√ßinde email alanƒ± yok`);

    assignedTo_uid = uid;
    assignedTo_email = email;
    logger.log("üë§ Approval assignee resolved", { assignedTo_uid, assignedTo_email });
  } catch (e) {
    logger.error("‚ùå Assignee resolve error:", e);
    throw e instanceof HttpsError ? e : new HttpsError("internal", "Atama belirlenemedi", e?.message || String(e));
  }

  try {
    // 2) Uygun IP kayƒ±tlarƒ±nƒ± tara ‚Üí olu≈üturulacak tasklarƒ±n ham verisini hazƒ±rla (YAZMA YOK)
    const allIpRecordsSnap = await adminDb.collection('ipRecords').get();
    const candidates = [];
    let recordsProcessed = 0;

    for (const doc of allIpRecordsSnap.docs) {
      const ipRecord = doc.data();
      const ipRecordId = doc.id;
      recordsProcessed++;

      // Durum filtresi
      if (ipRecord.status === 'ge√ßersiz' || ipRecord.status === 'rejected') {
        logger.log(`‚è© ${ipRecordId} '${ipRecord.status}', skip.`);
        continue;
      }

      // WIPO/ARIPO parent zorunluluƒüu
      if ((ipRecord.wipoIR || ipRecord.aripoIR) && ipRecord.transactionHierarchy !== 'parent') {
        logger.log(`‚è© ${ipRecordId} WIPO/ARIPO child, skip.`);
        continue;
      }

      // Yenileme tarihi hesapla
      let renewalDate = null;
      if (ipRecord.renewalDate) {
        if (typeof ipRecord.renewalDate?.toDate === 'function') {
          renewalDate = ipRecord.renewalDate.toDate();
        } else if (typeof ipRecord.renewalDate === 'string' || ipRecord.renewalDate instanceof Date) {
          const d = new Date(ipRecord.renewalDate);
          renewalDate = isNaN(d.getTime()) ? null : d;
        }
      }
      if (!renewalDate && ipRecord.applicationDate) {
        let appDate = null;
        if (typeof ipRecord.applicationDate?.toDate === 'function') {
          appDate = ipRecord.applicationDate.toDate();
        } else if (typeof ipRecord.applicationDate === 'string' || ipRecord.applicationDate instanceof Date) {
          const d = new Date(ipRecord.applicationDate);
          appDate = isNaN(d.getTime()) ? null : d;
        }
        if (appDate) {
          const d = new Date(appDate);
          d.setFullYear(d.getFullYear() + 10);
          renewalDate = d;
        }
      }
      if (!renewalDate) {
        logger.warn(`‚ö†Ô∏è ${ipRecordId} renewalDate yok/ge√ßersiz, skip.`);
        continue;
      }

      // Pencere kontrol√º
      if (renewalDate < sixMonthsAgo || renewalDate > sixMonthsLater) {
        logger.log(`‚è© ${ipRecordId} renewal (${renewalDate.toISOString().slice(0,10)}) pencere dƒ±≈üƒ±nda, skip.`);
        continue;
      }

      // Zaten a√ßƒ±k bir yenileme g√∂revi var mƒ±?
      const existing = await adminDb.collection('tasks')
        .where('relatedIpRecordId', '==', ipRecordId)
        .where('taskType', '==', taskTypeId)
        .where('status', 'in', ['awaiting_client_approval', 'open', 'in-progress'])
        .limit(1).get();
      if (!existing.empty) {
        logger.log(`‚ÑπÔ∏è ${ipRecordId} i√ßin mevcut yenileme g√∂revi var, skip.`);
        continue;
      }

      // UI metinleri
      const dueISO = renewalDate.toISOString().slice(0, 10);
      const title = `${ipRecord.title} Marka Yenileme`;
      const description = `${ipRecord.title} adlƒ± markanƒ±n yenileme s√ºreci i√ßin m√ºvekkil onayƒ± bekleniyor. Yenileme tarihi: ${renewalDate.toLocaleDateString('tr-TR')}.`;

      // Hen√ºz ID vermiyoruz; sadece veri ≈üablonu hazƒ±rlƒ±yoruz
      const data = {
        title,
        description,
        taskType: taskTypeId,
        relatedIpRecordId: ipRecordId,
        relatedIpRecordTitle: ipRecord.title,
        status: 'awaiting_client_approval',
        priority: 'medium',
        dueDate: dueISO,
        assignedTo_uid,
        assignedTo_email,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        history: [{
          action: 'Yenileme g√∂revi otomatik olarak olu≈üturuldu. M√ºvekkil onayƒ± bekleniyor.',
          timestamp: new Date().toISOString(),
          userEmail: assignedTo_email || 'sistem@evrekapatent.com'
        }]
      };

      candidates.push(data);
    }

    if (candidates.length === 0) {
      logger.log(`‚ÑπÔ∏è Yeni olu≈üturulacak yenileme g√∂revi yok. ƒ∞≈ülenen kayƒ±t: ${recordsProcessed}`);
      return { success: true, count: 0, taskIds: [], processed: recordsProcessed };
    }

    // 3) TEK TRANSAKTION: blok ID ayƒ±r + tasks/{ID} olarak yaz + counter'ƒ± g√ºncelle
    const result = await admin.firestore().runTransaction(async (tx) => {
      const counterRef = adminDb.collection('counters').doc('tasks');
      const counterSnap = await tx.get(counterRef);

      let lastId = 0;
      if (counterSnap.exists) {
        const data = counterSnap.data() || {};
        lastId = Number(data.lastId || 0);
        if (!Number.isFinite(lastId)) lastId = 0;
      } else {
        // ƒ∞lk kez: counter dok√ºmanƒ±nƒ± olu≈ütur
        tx.set(counterRef, { lastId: 0 });
        lastId = 0;
      }

      const newIds = [];
      for (let i = 0; i < candidates.length; i++) {
        const nextId = (lastId + 1 + i).toString(); // üî¢ belge ID‚Äôsi (taskNo alanƒ± yok!)
        const taskRef = adminDb.collection('tasks').doc(nextId);
        tx.set(taskRef, candidates[i]);
        newIds.push(nextId);
      }

      // Counter'ƒ± son deƒüere ta≈üƒ±
      const finalLastId = lastId + candidates.length;
      tx.set(counterRef, { lastId: finalLastId }, { merge: true });

      return newIds;
    });

    logger.log(`üéâ ${result.length} adet yenileme g√∂revi olu≈üturuldu:`, result);
    return { success: true, count: result.length, taskIds: result, processed: candidates.length };

  } catch (error) {
    logger.error('‚ùå Renewal task creation failed:', error);
    throw new HttpsError('internal', 'Yenileme g√∂revleri olu≈üturulurken bir hata olu≈ütu.', error?.message || String(error));
  }
});
// Yeni: Yenileme (taskType=22) i≈üi olu≈üturulduƒüunda m√º≈üteri mail taslaƒüƒ± a√ß
export const createClientNotificationOnRenewalTaskCreated = onDocumentCreated(
  { document: "tasks/{taskId}", region: "europe-west1" },
  async (event) => {
    const snap = event.data;
    const task = snap?.data() || {};
    const taskId = event.params.taskId;

    // Yalnƒ±zca yenileme + m√ºvekkil onayƒ± bekliyor
    if (String(task.taskType) !== "22") return null;
    if (task.status !== "awaiting_client_approval") return null;

    try {
      // 1) ƒ∞lgili IP kaydƒ± ve applicants
      const relatedIpRecordId = task.relatedIpRecordId;
      if (!relatedIpRecordId) return null;

      const ipRef = adminDb.collection("ipRecords").doc(relatedIpRecordId);
      const ipDoc = await ipRef.get();
      if (!ipDoc.exists) return null;

      const ipData = ipDoc.data() || {};
      const applicants = ipData.applicants || [];

      // 2) Alƒ±cƒ±lar (mevcut yardƒ±mcƒ±yƒ± kullan)
      // notificationType sisteminizde 'marka' / 'trademark' gibi; sizde kullanƒ±lan key'i ge√ßin
      const notificationType = (task.mainProcessType || "marka");
      const { to: toList = [], cc: ccList = [] } = await getRecipientsByApplicantIds(applicants, notificationType); // :contentReference[oaicite:4]{index=4}

      // 3) ≈ûablon kuralƒ± (taskType‚Äôa g√∂re) - veritabanƒ±nƒ±zda zaten tanƒ±mlƒ±
      // √ñrn: template_rules[sourceType='task', taskType='22'] ‚Üí templateId
      let templateId = null;
      try {
        const ruleSnap = await adminDb.collection("template_rules")
          .where("sourceType", "==", "task")
          .where("taskType", "==", "22")
          .limit(1)
          .get();
        if (!ruleSnap.empty) {
          templateId = ruleSnap.docs[0].data()?.templateId || null;
        }
      } catch (e) {
        console.warn("template_rules lookup failed:", e?.message || e);
      }

      // 4) Konu/G√∂vde (ƒ∞sterseniz burada template body/subject‚Äôi resolve edebilirsiniz;
      // yoksa bo≈ü ge√ßin, UI zaten taslak √ºzerinde d√ºzenliyor)
      const subject = task.title || `${ipData.title || "Marka"} Yenileme ‚Äì Onay Talebi`;
      const body    = task.description || "Yenileme i≈ülemi i√ßin onayƒ±nƒ±zƒ± rica ederiz.";

      // 5) Eksik alan kontrol√º ‚Üí ortak stat√º mantƒ±ƒüƒ±na uygun missing_info/awaiting‚Ä¶ (√∂rneƒüe paralel)
      const hasRecipients = (toList.length + ccList.length) > 0;
      const missingFields = [];
      if (!hasRecipients) missingFields.push("recipients");
      if (!templateId)    missingFields.push("template");
      const finalStatus = missingFields.length ? "missing_info" : "awaiting_client_approval";

      // 6) mail_notifications kaydƒ±nƒ± olu≈ütur (ortak ≈üemayla bire bir)
      const notificationDoc = {
        toList, ccList,                                 // ‚úî alƒ±cƒ±lar
        clientId: task.clientId || (applicants?.[0]?.id || null),
        subject, body,
        status: finalStatus,
        mode: "draft",
        isDraft: true,

        assignedTo_uid: task.assignedTo_uid || null,    // ‚úî mevcut atamayƒ± ta≈üƒ±
        assignedTo_email: task.assignedTo_email || null,

        sourceDocumentId: null,
        relatedIpRecordId,                               // ‚úî i≈üinizin ili≈ükilendiƒüi IP kaydƒ±
        associatedTaskId: taskId,                        // ‚úî bu task‚Äôa baƒülƒ±
        associatedTransactionId: null,

        templateId,
        notificationType,
        source: "task_renewal_auto",
        missingFields,

        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      };

      await adminDb.collection("mail_notifications").add(notificationDoc); // :contentReference[oaicite:5]{index=5}
      console.log("‚úÖ Renewal task notification draft created", { taskId });

      return null;
    } catch (err) {
      console.error("‚ùå renewal notification create failed:", err);
      return null;
    }
  }
);

// index.js (Yeni Yardƒ±mcƒ± Fonksiyon: Client/IP Bilgisi Bulma)

/**
 * Monitored Marka ID'si √ºzerinden en ili≈ükili IP Kaydƒ±nƒ± ve Client ID'sini bulur.
 */

export const handleBulletinDeletion = onMessagePublished(
  { topic: 'bulletin-deletion', region: 'europe-west1', memory: '1GiB', cpu: 1, timeoutSeconds: 540 },
  async (event) => {
    console.log('üéØ handleBulletinDeletion triggered');
    console.log('üì® Event data:', JSON.stringify(event.data, null, 2));
    
    const { bulletinId, operationId } = event.data.message.json || {};
    if (!bulletinId || !operationId) {
      console.warn('‚ö†Ô∏è handleBulletinDeletion: eksik payload', {
        bulletinId,
        operationId,
        rawJson: event?.data?.message?.json
      });
      return null;
    }
    
    console.log(`üöÄ Starting bulletin deletion: bulletinId=${bulletinId}, operationId=${operationId}`);
    
    try {
      await performBulletinDeletion(bulletinId, operationId);
      console.log(`‚úÖ Bulletin deletion completed: ${bulletinId}`);
    } catch (e) {
      console.error('üí• handleBulletinDeletion failed:', {
        bulletinId,
        operationId,
        error: e?.message || e,
        stack: e?.stack
      });
      
      // Hata durumunu operationStatus'a yaz
      try {
        const statusRef = db.collection('operationStatus').doc(operationId);
        await statusRef.update({
          status: 'error',
          message: `Handler hatasƒ±: ${e?.message || e}`,
          endTime: admin.firestore.FieldValue.serverTimestamp()
        });
      } catch (statusError) {
        console.error('Status update failed:', statusError);
      }
    }
    return null;
  }
);
